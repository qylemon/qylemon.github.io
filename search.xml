<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot之定时任务]]></title>
    <url>%2F2020%2F04%2F17%2FSpringBoot%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[通常我们业务上定时发送邮件，订单超时等操作需要使用到任务调度，市面上也有许多实现方式，比如：redis的TTL，rabbitMQ的死信+TTL，Quartz等，处于业务大小，自带整合等最终选择了Quartz 下面记录自己的整合和使用 简介Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。可以与 J2EE 与 J2SE 应用程序相结合也可以单独使用。允许程序开发人员根据时间的间隔来调度作业。实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。 代码实现导入pom包SpringBoot2.x整合了quartz 导入包即可使用1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt; 编写任务内容123456public class QuartzJob extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; // 任务内容 &#125;&#125; 任务执行类12345678910111213141516171819202122@Configurationpublic class MyScheduler &#123; @Bean(name = &quot;jobDetail&quot;) public JobDetail jobDetail()&#123; JobDetail jobDetail = JobBuilder.newJob(HelloWorld.class) // 定义Job类为HelloWorld类 也就是任务所在类 .withIdentity(&quot;eclipse1&quot;) // 定义name/group (&quot;&quot;,&quot;&quot;) .usingJobData(&quot;key&quot;,&quot;value&quot;).storeDurably() // 定义属性 .build(); return jobDetail; &#125; @Bean(name = &quot;trigger&quot;) public CronTriggerFactoryBean simpleJobTrigger1()&#123; CronTriggerFactoryBean trigger = new CronTriggerFactoryBean(); trigger.setJobDetail(jobDetail()); // cron表达式，每天0点执行一次 trigger.setCronExpression(&quot;0 0 0 * * ?&quot;); return trigger; &#125;&#125; 这时运行项目就能够正常使用定时任务了，测试可以修改corn表达式的时间 end]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>定时任务</tag>
        <tag>corn表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ab测试的记录]]></title>
    <url>%2F2020%2F04%2F17%2Fab%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[简介ab是apachebench命令的缩写 ，ab是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等 原理ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。 ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机 安装及启动 linux yum -y install httpd-tools #安装命令 Windows打开apacheBench官网 选择相应版本下载，下载后解压得到一个“Apache[版本号]”的目录，打开它能够看到这样一个页面进入bin目录下打开命令行，即可使用ab测试 使用方式及参数常用命令 ab -n xxx -c http://{host}:{port}/xxx 命令名称 说明 -n 请求个数 -c 并发数 -t 最大时间(s) -v 设置显示信息的详细程度(4,3,2) -V 显示版本 -help 参数说明 end]]></content>
      <categories>
        <category>测试</category>
        <category>测试工具</category>
      </categories>
      <tags>
        <tag>ab测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的世界部署服务端]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[帮朋友搭建了一个服务端 记录下搭建过程 准备工作在官网下载服务端文件下载地址下载后会得到一个jar包 将文件上传到服务器上 这里需要注意的是你的机器上需要有Java环境 搭建过程下载好了服务端的 .jar 文件之后，你就需要先运行一下，它会生成一些文件，包括一个 eula.txt 许可文件。第一次运行的时候，它会返回一个错误并退出。这是正常的。使用下面的命令运行它： java -Xms2048M -Xmx3472M -jar minecraft_server.1.12.2.jar nogui -Xms2048M 是你的服务端能使用的最小的内存，-Xmx3472M 是最大的内存。调整基于你服务器的硬件资源。如果你服务器上有 4GB 内存，并且不用服务器来干其他事情的话可以就这样留着不动。 在这条命令结束并返回一个错误之后，将会生成一个新的 eula.txt 文件。你需要同意那个文件里的协议。将eula修改为true状态 再次运行 java -Xms2048M -Xmx3472M -jar minecraft_server.1.12.2.jar nogui 就能够启动了 注意事项这时虽然正常启动了 但我们仍然不能够正常使用 我们需要进行相应的配置，打开根目录下的server.properties文件 修改ip port等相应的数据 重新运行 这个时候就能够正常连接了 这里请注意 此时的配置仅仅针对正版用户，非正版用户需要关闭正版验证onlinemode:false 此时重启服务 完美运行 end]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>安装与配置</tag>
        <tag>游戏服务端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux部署及基础环境配置(四)]]></title>
    <url>%2F2020%2F03%2F06%2Flinux%E5%AF%B9vue%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[记录一下关于node环境的安装及vue的打包部署 所需环境这里我们可以去node的官网下载node的tar包 上传至服务器进行解压 tar -xvf node-v10.13.0-linux-x64.tar #解压 mv node-v10.13.0-linux-x64 nodejs #重命名 确定nodejs文件夹中是否包含 node文件夹 建立软连接，改变为全局(这里一定要注意不要写错) ln -s /app/software/nodejs/bin/npm /usr/local/bin/ ln -s /app/software/nodejs/bin/node /usr/local/bin/ 安装cnpm–国内镜像速度比npm快很多 npm install -g cnpm –registry=https://registry.npm.taobao.org ln -s /home/node/node-v6.11.5-linux-x86/bin/cnpm /usr/local/bin/cnpm 安装vue脚手架vue-cli cnpm install -g vue-cli ln -s /home/formularoom/env/node-v8.1.2-linux-x64/bin/vue /usr/local/bin/vue vue打包当我们使用vue-cli脚手架完成一个项目的时候，下一步肯定会想要怎么把这个项目放到互联网上或者本地直接打开呢，我们在本地调试的时候只要命令行执行npm run dev就可以把这个项目跑起来，但是现在我们要把他放到服务器上的话用npm run build命令就可以啦。在执行完成后会生成一个dist的文件夹 我们将文件中的static文件夹和index页面打包上传服务器 注意点在图中能够清晰的看到文件中有一个提示tip:xxxx HTTP server; 这里就是告诉我们 vue打包后需要一个http服务 才能够启动 可以使用apache nginx等 这里我们记录使用nginx配置的过程 nginx部署vuenginx部署vue就显得十分简单了 在nginx中新启一个server 将文件填写如下12345678910 server&#123; listen &#123;port&#125;; server_name www.xxxx.com; location / &#123; alias /address/...; index index.html index.htm; &#125; &#125;配置完成后保存文件 检查当前nginx配置是否书写正确 然后重启nginx即可 end]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>环境部署</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux部署及基础环境配置(三)]]></title>
    <url>%2F2020%2F03%2F06%2Flinux%E5%AF%B9redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本次记录是关于中控服务的问题记载，场景是获取微信accessToken留存使用 其有效时长为两小时 安装redis 先确保我们拥有gcc 因为redis是c编写的 yum install gcc-c++ 下载redis安装包 wget http://download.redis.io/releases/redis-5.0.4.tar.gz 解压安装包 tar -zxf redis-5.0.4.tar.gz 编译 cd redis-5.0.4make 安装 make PREFIX=/usr/local/redis install copy redis.conf到安装目录 cp redis.conf /usr/local/redis 进入安装目录 cd /usr/local/redis/ 修改conf文件 123456vim redis.conf1.后台启动，daemonize yes2.绑定端口，port 6379 默认是6379 需要安全组开放端口3.指定数据存放路径，dir /usr/local/redis/log rdb存放的路径4.指定持久化方式，appendonly yes 启动redis ./bin/redis-server ./redis.conf 查看进程 ps aux | grep redis 进入客户端 ./bin/redis-cli –raw 处理中文乱码问题 get/set 测试是否能够正常使用 代码实现准备工作12345678910111213141516171819202122232425261. 新增pom文件&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;2.application## Redis 配置## Redis数据库索引（默认为0）spring.redis.database=0## Redis服务器地址spring.redis.host=127.0.0.1## Redis服务器连接端口spring.redis.port=6379## Redis服务器连接密码（默认为空）spring.redis.password=## 连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=8## 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1## 连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=8## 连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0## 连接超时时间（毫秒）spring.redis.jedis.timeout=1200 实现逻辑12345678910111213141516controller @Autowired private StringRedisTemplate stringRedisTemplate; ··· if (stringRedisTemplate.opsForValue().get(&quot;accessToken&quot;) == null)&#123; String accessToken = xx.accessToken(); //此处省略获取accessToken步骤 stringRedisTemplate.opsForValue().set(&quot;accessToken&quot;,accessToken,7000, TimeUnit.SECONDS); return ResponseVO.success(accessToken); &#125;else&#123; String accessToken = stringRedisTemplate.opsForValue().get(&quot;accessToken&quot;); return ResponseVO.success(accessToken); &#125; ··· 如此就能够实现中控服务的功能了。这里只是简单的用到了RedisTemplate的参数 下面记录一些常用参数 命令名称 说明 set(K key, V value) 新增一个字符串类型的值,key是键，value是值 get(Object key) 获取key键对应的值 append(K key, String value) 在原有的值基础上新增字符串到末尾 get(K key, long start, long end) 截取key键对应值得字符串，从开始下标位置开始到结束下标的位置(包含结束下标)的字符串。 getAndSet(K key, V value) 获取原来key键对应的值并重新赋新值 setBit(K key, long offset, boolean value) key键对应的值value对应的ascii码,在offset的位置(从左向右数)变为value getBit(K key, long offset) 判断指定的位置ASCII码的bit位是否为1 size(K key) 获取指定字符串的长度 increment(K key, double delta) 以增量的方式将double值存储在变量中 setIfAbsent(K key, V value) 如果键不存在则新增,存在则不改变已经有的值 set(K key, V value, long timeout, TimeUnit unit) 设置变量值的过期时间 set(K key, V value, long offset) 覆盖从指定位置开始的值 multiSet(Map&lt;? extends K,? extends V&gt; map) 设置map集合到redis multiGet(Collection keys) 根据集合取出对应的value值 multiSetIfAbsent(Map&lt;? extends K,? extends V&gt; map) 如果对应的map集合名称不存在，则添加，如果存在则不做修改 end]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>环境部署</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux部署及基础环境配置(二)]]></title>
    <url>%2F2020%2F03%2F04%2Flinux%E5%AF%B9nginx%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[单部署tomcat足够满足我们对后端项目的需要，但tomcat应当被理解为容器，要处理http server还应当更上一层 这时nginx是一个很好的选择 安装nginx安装前的准备 需要依赖的环境gcc、pcre-devel、zlib-devel、openssl-devel yum -y install gcc pcre-devel zlib-devel openssl openssl-devel 开始安装在nginx官网下载一个tar.gz包 并移动到/usr/local下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556## 解压tar -zxvf nginx-1.9.9.tar.gz##进入nginx目录cd nginx-1.9.9## 配置./configure --prefix=/usr/local/nginx# makemake &amp;&amp; make install# cd到刚才配置的安装目录/usr/loca/nginx/./sbin/nginx -t出现success则为成功cd /usr/local/nginx/sbin./nginx //启动nginx``` ### 开机自启动&gt; vi /etc/rc.d/rc.local![](https://images2015.cnblogs.com/blog/964175/201705/964175-20170521122817057-1077865607.png)## 配置访问tomcat&gt; vi /conf/nginx.conf![](https://images2015.cnblogs.com/blog/656746/201605/656746-20160510160506952-1299797999.png)将选中部分的tomcat_server换成你的端口，下方链接相同即可完成配置## 配置HTTPS访问在配置https访问前需要准备以下三点1. 查看你的nginx是否安装了`http_ssl_module`模块2. 申请ssl证书3. 查看是否开启443端口### 准备工作查看是否开启端口非常简单&gt; netstat -ano | grep 443申请证书也非常简单 各云上应该都有免费个人证书 规则填写即可签发#### 是否安装https模块&gt; $ /usr/local/nginx/sbin/nginx -V 查看是否安装模块 在安装nginx编译时加上`--with-http_ssl_module`可以直接安装如果安装过 会出现 `configure arguments: --with-http_ssl_module`的字样，那么可以跳过安装步骤 下面记录以下 没有安装如何处理#### 安装https模块1. 先找到安装包的位置 如不记得 可以使用whereis或find的方式查找 cd到nginx安装包的根目录下，&gt; ./configure --with-http_ssl_module # 安装2. 然后进行`make`操作 注意！这里不需要make install 不然就会覆盖3. 关闭掉现有的nginx服务器&gt; /usr/local/nginx/sbin/nginx -s stop4. cp ./objs/nginx /usr/local/nginx/sbin/ # 将新编译好的版本覆盖原有的nginx这时已经完成了大部分工作 在nginx.conf同级创建一个文件夹将证书的公私钥放入文件夹中 我们回头去修改nginx.conf 文件的443端口内容 vi /usr/local/nginx/conf/nginx.conf 将443的server服务注释取消(如下方伪代码) server { listen 443 ssl ; server_name xxx; ssl_certificate “/…/nginx/conf/xxx/1_www.xx.xxx.crt&quot;（你刚才传到服务器上的证书地址，叫你记住的哦）; ssl_certificate_key “/…/nginx/conf/xxx/2_www.xxx.xx.key&quot;（你刚才传到服务器上的证书地址）; ······ }`保存文件 然后重启nginx 重启前我们阔以通过 nginx -t 检查当前配置是否正常 nginx -s reload 注意点此时可能会出现 这样的画面这是因为端口被占用 使用 netstat -ntlp 查看被占用的端口kill 进程号 再次重启即可 多项目部署可以选择同容器部署，比如一个tomcat多项目，这里我选择了多tomcat单项目，需要在server.xml中修改三个默认监听端口，然后运行起来，在nginx.conf中新增一个server，和之前方式一样就可以了。 性能调优Http跳转Https如无特殊需求阔以同时访问 跳转可以参考301跳转 常用维护命令 命令 说明 ./nginx -t 查看当前配置是否书写正确 ./nginx 启动nginx ./nginx -s reload 重启nginx ps -ef &#124; grep nginx 查看nginx进程 kill -QUIT 主进程号 从容停止 kill -TERM 主进程号 快速停止 kill -9 nginx 强制停止 end]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>环境部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序获取二维码]]></title>
    <url>%2F2020%2F02%2F19%2F%E8%8E%B7%E5%8F%96%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%A0%81%2F</url>
    <content type="text"><![CDATA[小程序本身通过提供的页面方法能够实现右上角分享给朋友，但是其他平台却不能直发，通常大家的解决方式是使用canvas做一张带小程序码的海报分享图，以下是微信提供的服务端API。 接口名称 说明 createQRCode 可接受path参数较长，生成个数10W getUnlimited 可接受页面参数较短，生成个数不受限 get 可接受path参数较长，生成个数10W 其他从文档中并未发现明显区别，下面记录一下生成和小程序的测试方法，canvas将会在后续前端文章中补充 操作如下服务端服务端总共需要调用两次接口 首先需要获取到必须参数accessToken值，调用如下方法 getAccessToken GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET 注意点这里的accessToken每天限量2k，需要保存下来使用 然后调用生成code的方法 getUnlimited POST https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=ACCESS_TOKEN 参数通过scene传递 最大支持32个字符 注意点这里的access_token是直接当作parameter的，scene参数一定要以raw的形式传递 客户端写功能时肯定还没有上线 那么我们如何测试呢，操作如下 将做好的画布海报授权保存到设备 跳转到的页面中onload方法中加入如下代码 123456Page(&#123; onLoad (options) &#123; // scene 需要使用 decodeURIComponent 才能获取到生成二维码时传入的 scene const scene = decodeURIComponent(options.scene) &#125;&#125;) 将编译修改为二维码编译，打开刚刚保存的分享海报，就能够获取scene参数啦 注意点这里生成的qrcode 并不能直接上canvas，因为画布不支持base64，这里我们需要将其转化为普通的网络图片 之后再使用wx.getImageInfo或者wx.chooseImage进行调用 转化方式如下1234567891011121314151617181920212223242526272829303132333435363738394041base64src.jsconst fsm = wx.getFileSystemManager();const FILE_BASE_NAME = &apos;tmp_base64src&apos;; //自定义文件名function base64src(base64data, cb) &#123; const [, format, bodyData] = /data:image\/(\w+);base64,(.*)/.exec(base64data) || []; if (!format) &#123; return (new Error(&apos;ERROR_BASE64SRC_PARSE&apos;)); &#125; const filePath = `$&#123;wx.env.USER_DATA_PATH&#125;/$&#123;FILE_BASE_NAME&#125;.$&#123;format&#125;`; const buffer = wx.base64ToArrayBuffer(bodyData); fsm.writeFile(&#123; filePath, data: buffer, encoding: &apos;binary&apos;, success() &#123; cb(filePath); &#125;, fail() &#123; return (new Error(&apos;ERROR_BASE64SRC_WRITE&apos;)); &#125;, &#125;);&#125;;export &#123; base64src &#125;;//share.jsimport &#123; base64src &#125; from &apos;../../utils/base64src.js&apos;Page(&#123; data: &#123; baseImg:&quot;/data:image/png;base64,xxxxx==&quot; ... onLoad: function () &#123; ··· base64src(this.data.base, res =&gt; &#123; console.log(res) // 返回图片地址，直接赋值到image标签即可 &#125;); ··· 如上就能够完成了 这里顺嘴一提 getUnlimited虽然对总数没有限制 但是每分钟限制5k 如果大量生成 官方说是建议提前生成 这个自己研究吧(^_^) end]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云存储静态资源]]></title>
    <url>%2F2020%2F02%2F15%2F%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[七牛云通常用来存储图片等静态资源，记录下操作过程 后端操作如下引入pom文件123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;com.qiniu&lt;/groupId&gt; &lt;artifactId&gt;qiniu-java-sdk&lt;/artifactId&gt; &lt;version&gt;7.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.qiniu&lt;/groupId&gt; &lt;artifactId&gt;happy-dns-java&lt;/artifactId&gt; &lt;version&gt;0.1.4&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;dependency&gt; util文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.xx.xx.util;// 包部分以省略import java.io.IOException;import java.util.*;import com.qiniu.*;import okhttp3.*;public class QiniuUtil &#123; // 设置需要操作的账号的AK和SK private static final String ACCESS_KEY = &quot;你的ACCESS_KEY&quot;; private static final String SECRET_KEY = &quot;你的SECRET_KEY&quot;; // 要上传的空间 private static final String bucketname = &quot;你的空间名称&quot;; // 密钥 private static final Auth auth = Auth.create(ACCESS_KEY, SECRET_KEY); private static final String DOMAIN = &quot;你的图片上传路径&quot;; private static final String style = &quot;自定义的图片样式&quot;; public String getUpToken() &#123; return auth.uploadToken(bucketname, null, 3600, new StringMap().put(&quot;insertOnly&quot;, 1)); &#125; // 普通上传 public String upload(String filePath, String fileName) throws IOException &#123; // 创建上传对象 UploadManager uploadManager = new UploadManager(); try &#123; // 调用put方法上传 String token = auth.uploadToken(bucketname); if(token.isEmpty() || token==&quot;&quot;) &#123; System.out.println(&quot;未获取到token，请重试！&quot;); return null; &#125; Response res = uploadManager.put(filePath, fileName, token); // 打印返回的信息 System.out.println(res.bodyString()); if (res.isOK()) &#123; Ret ret = res.jsonToObject(Ret.class); //如果不需要对图片进行样式处理，则使用以下方式即可 //return DOMAIN + ret.key; return DOMAIN + ret.key + &quot;?&quot; + style; &#125; &#125; catch (QiniuException e) &#123; Response r = e.response; // 请求失败时打印的异常的信息 System.out.println(r.toString()); try &#123; // 响应的文本信息 System.out.println(r.bodyString()); &#125; catch (QiniuException e1) &#123; // ignore &#125; &#125; return null; &#125; //base64方式上传 public String put64image(byte[] base64, String key) throws Exception&#123; String file64 = Base64.encodeToString(base64, 0); Integer l = base64.length; String url = &quot;http://upload.qiniu.com/putb64/&quot; + l + &quot;/key/&quot;+ UrlSafeBase64.encodeToString(key); //非华东空间需要根据注意事项 1 修改上传域名 RequestBody rb = RequestBody.create(null, file64); Request request = new Request.Builder(). url(url). addHeader(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;) .addHeader(&quot;Authorization&quot;, &quot;UpToken &quot; + getUpToken()) .post(rb).build(); //System.out.println(request.headers()); OkHttpClient client = new OkHttpClient(); okhttp3.Response response = client.newCall(request).execute(); System.out.println(response); //如果不需要添加图片样式，使用以下方式 //return DOMAIN + key; return DOMAIN + key + &quot;?&quot; + style; &#125; // 普通删除(暂未使用以下方法，未测试) public void delete(String key) throws IOException &#123; // 实例化一个BucketManager对象 BucketManager bucketManager = new BucketManager(auth); // 此处的25是去掉：http://xxxx.com/,剩下的key就是图片在七牛云的名称,截取到问号 问号后是图片的水印处理 key = key.substring(25,key.indexOf(&quot;?&quot;)); try &#123; // 调用delete方法移动文件 bucketManager.delete(bucketname, key); &#125; catch (QiniuException e) &#123; // 捕获异常信息 Response r = e.response; System.out.println(r.toString()); &#125; &#125; class Ret &#123; public long fsize; public String key; public String hash; public int width; public int height; &#125;&#125; controller代码123456789101112131415161718192021222324252627282930313233343536@ResponseBody@PostMapping(&quot;/uploadImg&quot;)public ResultInfo uploadImg(@RequestParam MultipartFile image, HttpServletRequest request) &#123; ResultInfo result = new ResultInfo(); if (image.isEmpty()) &#123; result.setCode(400); result.setMsg(&quot;文件为空，请重新上传&quot;); return result; &#125; try &#123; byte[] bytes = image.getBytes(); String imageName = UUID.randomUUID().toString(); QiniuUtil qiniuUtil = new QiniuUtil(); try &#123; //使用base64方式上传到七牛云 String url = qiniuUtil.put64image(bytes, imageName); result.setCode(200); result.setMsg(&quot;文件上传成功&quot;); //此处需要引入鉴黄的判断 if(qiniuUtil.pornography(url))&#123; result.setInfo(url); &#125;else&#123; // 处理删除业务逻辑 并返回提示 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; catch (IOException e) &#123; result.setCode(500); result.setMsg(&quot;文件上传发生异常！&quot;); return result; &#125;&#125; 如此就能够实现上传功能了，但听说在上传前还需要鉴识颜色，就需要对util进行一些小幅修改，修改如下。 修改操作如下修改pom包版本如未修改高版本pom文件 该部分会出现com.qiniu.common.QiniuException异常12345&lt;dependency&gt; &lt;groupId&gt;com.qiniu&lt;/groupId&gt; &lt;artifactId&gt;qiniu-java-sdk&lt;/artifactId&gt; &lt;version&gt;7.2.7&lt;/version&gt;&lt;/dependency&gt; util文件种添加鉴别部分代码12345678910111213141516171819202122232425262728293031323334353637public static Boolean pornography(String pis)&#123; Auth auth = Auth.create(ACCESS_KEY, SECRET_KEY); String url = &quot;http://ai.qiniuapi.com/v3/image/censor&quot;; String host = &quot;ai.qiniuapi.com&quot;; String body = &quot;&#123; \&quot;data\&quot;: &#123; \&quot;uri\&quot;: \&quot;&quot;+pis+&quot;\&quot; &#125;, \&quot;params\&quot;: &#123; \&quot;scenes\&quot;: [ \&quot;pulp\&quot;, \&quot;terror\&quot;, \&quot;politician\&quot; ] &#125; &#125;&quot;; String contentType = &quot;application/json&quot;; String method = &quot;POST&quot;; String qiniuToken = &quot;Qiniu &quot; + auth.signRequestV2(url, method, body.getBytes(), contentType); StringMap header = new StringMap(); header.put(&quot;Host&quot;, host); header.put(&quot;Authorization&quot;, qiniuToken); header.put(&quot;Content-Type&quot;, contentType); Client client = new Client(); Response response = null; String str =&quot;&quot;; try &#123; response = client.post(url, body.getBytes(), header, contentType); str = response.bodyString(); &#125; catch (QiniuException e) &#123; e.printStackTrace(); &#125; if (!str.equals(&quot;&quot;))&#123; JsonParser jp = new JsonParser(); //将json字符串转成json对象 JsonObject jo = jp.parse(str).getAsJsonObject(); String label = jo.get(&quot;result&quot;).getAsJsonObject().get(&quot;scenes&quot;).getAsJsonObject() .get(&quot;pulp&quot;).getAsJsonObject().get(&quot;details&quot;).getAsJsonArray().get(0).getAsJsonObject().get(&quot;label&quot;).getAsString(); if (label.equals(&quot;pulp&quot;))&#123; return false; &#125; &#125; return true;&#125; 修改util部分代码 添加空间地区类参数 123456// 空间的地区类型//Region.region0() 华东一 其他请参考七牛云文档public Configuration getConfiguration()&#123; Configuration cfg = new Configuration(Region.region0()); return cfg;&#125; 修改普通上传方法中的 创建上传对象 12// 创建上传对象UploadManager uploadManager = new UploadManager(getConfiguration()); 如写了删除方法也需要在方法中修改 12// 实例化一个BucketManager对象BucketManager bucketManager = new BucketManager(auth,getConfiguration()); 这样工具类就整合完成了，后续如有此类知识点会在文中补充 end已经过测试，注意点已补充在文中。 cname所绑定的域名一定要尾部加上/ 或者在util中修改拼接的方式]]></content>
      <categories>
        <category>静态存储</category>
      </categories>
      <tags>
        <tag>静态存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iDRAC6 远程控制卡配置与使用]]></title>
    <url>%2F2020%2F02%2F09%2FiDRAC6%20%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8D%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这是第一篇运维类的文章 非常高兴能够记录新的一类文 远程卡作用及特点远程卡是服务器的远程管理方案，远程卡分为独立远程卡和集成远程卡，通过远程卡可实现处理系统崩溃，服务器无响应，电源控制等管理，其优点在于： 独立于操作系统和BIOS ，服务器无须安装任何程序，只须作相应配置即可。 主控端无须安装任何额外设备，使用 Telnet/SSH/ 浏览器方式 即可控制 。 可以实现对 BIOS 甚至 操作系统的完全控制。 如何设置启动远程卡 然后开启机器 当出现以下界面时按 Ctrl+E 进入设置： 启用iDRAC6 LAN 和 IPMI Over LAN 功能（按左右箭头键设置为 On ) 接下来，为远程控制卡配置IP 信息，在图二界面中选择 LAN Parameters ： NIC Selecttion 设置为 Shared With Failover All LOMS, 这样的好处就是只要任何一个网卡是连通的，远程控制卡就可以正常连接。（提示：青绿色字体选项无法修改也无须修改。） 请按自己需要，设置固定或动态IP, 如果需要直接远程连接到控制卡，则需要为其指定有效的网关。 DNS 不用设置。设置完毕后，按 ESC 返回到图二界面中。然后设置管理用户及密码；在图二所示界面中选择“LAN User Configuration ” , 按图示设置用户名和密码：配置完毕后，保存BIOS 设置后，服务器重新启动。(ESC→ save change and exit【保存并退出】) 验证是否生效此时服务器开机后 使用其他计算机ping刚才设置的IP时 能够看到能通即没有问题。 查看远程卡界面的方式这里我已知的方法有两种 方式一浏览器访问远程卡IP这里继续访问即可 （因为现在是从局域网访问了 证书是无效的） 登录界面后会有类似下图界面单击按钮 我们将会下载对应的映像，就像这样 方式二将刚刚下载的文件重命名从括弧开始的部分全部删除保留文件名即可，在该文件的同级目录下运行命令javaws viewer.jnlp即可使用1ps：该方法需要jdk环境支持 且版本在1.6或1.7 -----1.8因为安全性提高暂时无法访问如不知版本可在cmd中使用java -version查看版本号 远程卡实现电源类管理除上述两种方法外 还有一种也是能够实现的 这里补充一下 BMC工具该工具安装包可在官网下载→工具包地址里面包含了win和linux等相应操作工具，这里记录一下Windows的(ipmish)相关命令 ipmish.exe -ip 控制卡ip -u 用户名 -p 密码 power 命令 变量以通过加粗表注 命令如下表格 命令名称 说明 reset 重启 off 关机 On 开机 Status 查看电源状态 cycle 先关机，再延迟启动(即冷启动) -force 强制关机 end]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序的常用组件、布局记载(二)]]></title>
    <url>%2F2020%2F02%2F07%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6and%E5%B8%83%E5%B1%80%E8%AE%B0%E8%BD%BD(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[简述本贴将持续记录碰到的常见布局、组件等 小程序页面置顶置底置顶或置底其本质是一样的 都可以通过绝对定位来实现 代码如下 置顶&lt;view class=&quot;page_head&quot; style=&quot;position:fixed; top:0;width: 750rpx;&quot;&gt;&lt;/view&gt; 置底&lt;view class=&quot;page_foot&quot; style=&quot;position:fixed; bottom:0;width: 750rpx;&quot;&gt;&lt;/view&gt; 小程序自定义弹框自定义弹框 小程序文档中有个wx.shiwModal能够实现，但并不能满足需求，类似于选择框；自定义实现弹框 实现如下wxml:123456789&lt;view class=&quot;mask&quot; catchtouchmove=&quot;preventTouchMove&quot; wx:if=&quot;&#123;&#123;showModal&#125;&#125;&quot;&gt;&lt;/view&gt; &lt;view class=&quot;modalDlg&quot; wx:if=&quot;&#123;&#123;showModal&#125;&#125;&quot;&gt; &lt;image src=&quot;/figures/logo-smile.png&quot;/&gt; &lt;text&gt;欢迎来到模态对话框~&lt;/text&gt; &lt;button bindtap=&quot;go&quot;&gt;点我可以关掉对话框&lt;/button&gt;&lt;/view&gt; &lt;button bindtap=&quot;submit&quot;&gt;点我弹窗&lt;/button&gt; wxss:12345678910111213141516171819202122232425.mask&#123; width: 100%; //蒙板占满屏幕 height: 100%; //蒙板占满屏幕 position: fixed; top: 0; left: 0; background: #000; z-index: 9000; opacity: 0.7;&#125; .modalDlg&#123; width: 580rpx; height: 620rpx; position: fixed; top: 50%; left: 0; z-index: 9999; //此处悬浮要大于蒙层 margin: -370rpx 85rpx; background-color: #fff; border-radius: 36rpx; display: flex; flex-direction: column; align-items: center;&#125; js:12345678910111213141516171819202122232425Page(&#123; data: &#123; showModal: false &#125;, submit: function() &#123; this.setData(&#123; showModal: true &#125;) &#125;, //空函数，使用catch事件 阻止touchmove这样一个冒泡事件继续向下传递 preventTouchMove: function() &#123; &#125;, go: function() &#123; this.setData(&#123; showModal: false &#125;) &#125; &#125;) end]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swagger的一次报错]]></title>
    <url>%2F2020%2F02%2F05%2Fswagger%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[报错Unable to infer base url.最近在搭脚手架 加入swagger2的时候 run项目发现突然报错了，错误信息如下1234Unable to infer base url.This is common when using dynamic servlet registration or when the API is behind an API Gateway.The base url is the root of where all the swagger resources are served. For e.g. if the api is available at http://example.org/api/v2/api-docs then the base url is http://example.org/api/.Please enter the location manually: 问题排查第一反应是启动类未定义相应注解，看了之后排除了，之后就考虑到了版本问题，最开始引入的是2.8版本，感觉不太顺手，又回退版本到2.4，这成为了本次问题的关键，将浏览器的缓存清除后，问题完美解决 end]]></content>
      <categories>
        <category>swagger</category>
      </categories>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序的常用组件、布局记载(一)]]></title>
    <url>%2F2020%2F01%2F09%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6and%E5%B8%83%E5%B1%80%E8%AE%B0%E8%BD%BD(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[简述本贴将持续记录碰到的常见布局、组件等 返顶方式在页面内容过长时 我们通常会通过设置按钮进行锚点返顶操作，小程序中也有同样方式进行该操作 方式一使用view形式的回到顶部wxml1&lt;image src=&apos;../../img/button-top.png&apos; class=&apos;goTop&apos; hidden=&apos;&#123;&#123;!floorstatus&#125;&#125;&apos; bindtap=&quot;goTop&quot;&gt;&lt;/image&gt; wxss12345678910/* 返回顶部 */.goTop&#123; height: 80rpx; width: 80rpx; position: fixed; bottom: 50rpx; background: rgba(0,0,0,.3); right: 30rpx; border-radius: 50%;&#125; js123456789101112131415161718192021222324252627// 获取滚动条当前位置onPageScroll: function (e) &#123; console.log(e) if (e.scrollTop &gt; 100) &#123; this.setData(&#123; floorstatus: true &#125;); &#125; else &#123; this.setData(&#123; floorstatus: false &#125;); &#125;&#125;,//回到顶部goTop: function (e) &#123; // 一键回到顶部 if (wx.pageScrollTo) &#123; wx.pageScrollTo(&#123; scrollTop: 0 &#125;) &#125; else &#123; wx.showModal(&#123; title: &apos;提示&apos;, content: &apos;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&apos; &#125;) &#125;&#125;, 方式二使用scroll-view形式的回到顶部wxml12&lt;scroll-view scroll-y scroll-top=&apos;&#123;&#123;topNum&#125;&#125;&apos; bindscroll=&quot;scrolltoupper&quot;&gt;&lt;image src=&apos;../../img/button-top.png&apos; class=&apos;goTop&apos; hidden=&apos;&#123;&#123;!floorstatus&#125;&#125;&apos; bindtap=&quot;goTop&quot;&gt;&lt;/image&gt; wxss(同上)js1234567891011121314151617181920// 获取滚动条当前位置scrolltoupper:function(e)&#123; console.log(e) if (e.detail.scrollTop &gt; 100) &#123; this.setData(&#123; floorstatus: true &#125;); &#125; else &#123; this.setData(&#123; floorstatus: false &#125;); &#125;&#125;,//回到顶部goTop: function (e) &#123; // 一键回到顶部 this.setData(&#123; topNum: this.data.topNum = 0 &#125;);&#125;, 居中方式方式一(flex流布局)12justify-content：center；align-items：center； 方式二(一般布局)12text-align:center;align-items:center; end]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue数据处理]]></title>
    <url>%2F2020%2F01%2F09%2Fvue%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[简述一般我们会将数据通过json等方式传递到前端，但是性别等需要汉字的字段则不会直接存入数据库(浪费内存)，于是传递到前端就是0，1，2…,关于数据转换记录几种处理方式 逐条处理当数据放入需要展示的位置时我们通过v:if处理可能碰到的情况，举例:123456&lt;el-table-column prop=&quot;ud_status&quot; label=&quot;性别&quot; :formatter=&quot;formatRole&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt;// jsformatRole: function(row, column) &#123; return row.ud_status == &apos;0&apos; ? &quot;男&quot; : row.ud_status == &apos;1&apos; ? &quot;女&quot; : &quot;?&quot;;&#125;, 模板统一的情况当表格多个列通过循环进行展示时，我们将无法对模板单一字段进行处理，可以通过数据遍历的方式进行处理，举例:12345678910// jsthis.usersData.map(function (val) &#123; if (val.gender == 0) &#123; val.gender = &apos;男&apos; &#125; else if (val.gender == 1) &#123; val.gender = &apos;女&apos; &#125; else &#123; val.gender = &apos;?&apos; &#125;&#125;) 最后为了方便可以将统一的这种情况进行封装使用，既可以愉快的处理逻辑，又可以”偷懒”了~(￣▽￣)~*]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot完美跨域]]></title>
    <url>%2F2019%2F12%2F18%2Fspringboot%E5%AE%8C%E7%BE%8E%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[什么是跨域前后端分离开发的场景已经趋于常态，跨域就必不可少 URL 说明 是否允许通信 www.baidu.com/a.jswww.baidu.com/b.js 同域 允许通讯 www.baidu.com:8080/a.jswww.baidu.com:8081/b.js 同域不同端口 不允许通信(跨域） www.baidu.com/a.jswww.xxx.com/b.js 不同域 不允许通信(跨域） 有哪些配置方式springboot的跨域一般有两种情况，请求上加注解和统一配置(configration/filter)，像我这样图方便的人就喜欢统一配置，网上的通用配置很多 哪儿尬然而尴尬的事情发生了，前端携带token请求后端接口时被拦截了500，仔细看了请求 发现浏览器在发送真实请求前会发送一个options预请求进行校验需要满足以下条件 请求方法不是GET/HEAD/POST POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain 请求设置了自定义的header字段 显然 token并不属于官方请求头 那么就是这个通用失效的原因了，贴上这次使用的代码，下次不尬 @Bean public FilterRegistrationBean corsFilter() { // 注册CORS过滤器 UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); // 是否支持安全证书 config.addAllowedOrigin(&quot;*&quot;); // 允许任何域名使用 config.addAllowedHeader(&quot;*&quot;); // 允许任何头 config.addAllowedMethod(&quot;*&quot;); // 允许任何方法（post、get等） // 预检请求的有效期，单位为秒。 // config.setMaxAge(3600L); source.registerCorsConfiguration(&quot;/**&quot;, config); FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source)); bean.setOrder(0); return bean; } end]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memcached入门与应用]]></title>
    <url>%2F2019%2F12%2F12%2Fmemcached%E5%85%A5%E9%97%A8%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[是什么是一款高性能、分布式的内存对象缓存系统可以有效地分担数据库负载，基于libevent事件处理实现无阻塞通信（高性能原因之一），是以key/value键值对形式存储 有什么优势熟悉memcached的童鞋可能知道 一般它都会被和reids进行比较，两者各有千秋，redis支持5种数据类型存储，memcached仅支持key/value；但memcached的性能优于redis。 能干啥使用memcached做缓存可以有效地减轻数据库压力，提高系统性能 关于存储底层存储内存分配机制memcached数据最终会存入chunk，分配时通过slab分配器决定的，slabclass会记录slab的信息，每个slab下有无数个等份page，page下有无数个等份chunk，chunk是数据的真实存储单位，默认大小为80byte，slab的大小取决于自增长因子 寻找chunk的过程memcached的删除属于逻辑删除，删除和过期的chunk会标识后放入slot，以供后续存储的空间处理，当在slot中没有找到不用的chunk时，会寻找空闲chunk存储，当两者都不满足时会触发LRU机制，在寻找chunk存储时，不会因为其他slab有空闲就不触发LRU流程 memcached分布式的hash算法①余数hash由名可得，这种算法时取余数获得存储的位置，主要是将key值转换为hash值然后除以机器数量取余。此方法有很大缺陷，一旦机器数量变化(增加节点/机器损坏)数据将会失效； ②※一致性hash将服务器列表(真实节点)和虚拟节点分布在一个0-2的32次方的圆上。同样key取hash值，通过余数方式确定存放机器，如果命中的时虚拟节点则顺时针找到下一个真实节点存储。此方法影响更小、易排查 哪儿尬这次没出现啥尬的，安装过程就不记录了。碰到新的方法或问题，下次再记录 endmemcached基于libevent，那么安装也依赖于libevent，所以安装时需要先安装libeventmemcached可以通过设置CAS或者版本号的方式来避免重复修改]]></content>
      <categories>
        <category>memcached</category>
      </categories>
      <tags>
        <tag>memcached</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信支付记录篇]]></title>
    <url>%2F2019%2F12%2F12%2F%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[微信支付准备工作我们需要从小程序和商户平台获取如下参数 参数名称 说明 appid 小程序appid mch_id 商户id key 商户密钥 代码实现1234567891011121314151617配置类 wechatConfig(来源woniu95)public class WechatConfig &#123; //小程序appid public static final String appid = &quot;&quot;; //微信支付的商户id public static final String mch_id = &quot;&quot;; //微信支付的商户密钥 public static final String key = &quot;&quot;; //支付成功后的服务器回调url，这里填PayController里的回调函数地址 public static final String notify_url = &quot;&quot;; //签名方式，固定值 public static final String SIGNTYPE = &quot;MD5&quot;; //交易类型，小程序支付的固定值为JSAPI public static final String TRADETYPE = &quot;JSAPI&quot;; //微信统一下单接口地址 public static final String pay_url = &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223工具类 payutilpublic class PayUtil &#123; /** * 签名字符串 * * @param text 需要签名的字符串 * @param key 密钥 * @param input_charset 编码格式 * @return 签名结果 */ public static String sign(String text, String key, String input_charset) &#123; text = text + &quot;&amp;key=&quot; + key; return DigestUtils.md5Hex(getContentBytes(text, input_charset)); &#125; /** * 签名字符串 * * @param text 需要签名的字符串 * @param sign 签名结果 * @param key 密钥 * @param input_charset 编码格式 * @return 签名结果 */ public static boolean verify(String text, String sign, String key, String input_charset) &#123; text = text + key; String mysign = DigestUtils.md5Hex(getContentBytes(text, input_charset)); if (mysign.equals(sign)) &#123; return true; &#125; else &#123; return false; &#125; &#125; /** * @param content * @param charset * @return * @throws java.security.SignatureException * @throws UnsupportedEncodingException */ public static byte[] getContentBytes(String content, String charset) &#123; if (charset == null || &quot;&quot;.equals(charset)) &#123; return content.getBytes(); &#125; try &#123; return content.getBytes(charset); &#125; catch (UnsupportedEncodingException e) &#123; throw new RuntimeException(&quot;MD5签名过程中出现错误,指定的编码集不对,您目前指定的编码集是:&quot; + charset); &#125; &#125; private static boolean isValidChar(char ch) &#123; if ((ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) || (ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;) || (ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;)) return true; if ((ch &gt;= 0x4e00 &amp;&amp; ch &lt;= 0x7fff) || (ch &gt;= 0x8000 &amp;&amp; ch &lt;= 0x952f)) return true;// 简体中文汉字编码 return false; &#125; /** * 除去数组中的空值和签名参数 * * @param sArray 签名参数组 * @return 去掉空值与签名参数后的新签名参数组 */ public static Map&lt;String, String&gt; paraFilter(Map&lt;String, String&gt; sArray) &#123; Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;(); if (sArray == null || sArray.size() &lt;= 0) &#123; return result; &#125; for (String key : sArray.keySet()) &#123; String value = sArray.get(key); if (value == null || value.equals(&quot;&quot;) || key.equalsIgnoreCase(&quot;sign&quot;) || key.equalsIgnoreCase(&quot;sign_type&quot;)) &#123; continue; &#125; result.put(key, value); &#125; return result; &#125; /** * 把数组所有元素排序，并按照“参数=参数值”的模式用“&amp;”字符拼接成字符串 * * @param params 需要排序并参与字符拼接的参数组 * @return 拼接后字符串 */ public static String createLinkString(Map&lt;String, String&gt; params) &#123; List&lt;String&gt; keys = new ArrayList&lt;&gt;(params.keySet()); Collections.sort(keys); String prestr = &quot;&quot;; for (int i = 0; i &lt; keys.size(); i++) &#123; String key = keys.get(i); String value = params.get(key); if (i == keys.size() - 1) &#123;// 拼接时，不包括最后一个&amp;字符 prestr = prestr + key + &quot;=&quot; + value; &#125; else &#123; prestr = prestr + key + &quot;=&quot; + value + &quot;&amp;&quot;; &#125; &#125; return prestr; &#125; /** * @param requestUrl 请求地址 * @param requestMethod 请求方法 * @param outputStr 参数 */ public static String httpRequest(String requestUrl, String requestMethod, String outputStr) &#123; // 创建SSLContext StringBuffer buffer = null; try &#123; URL url = new URL(requestUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(requestMethod); conn.setDoOutput(true); conn.setDoInput(true); conn.connect(); //往服务器端写内容 if (null != outputStr) &#123; OutputStream os = conn.getOutputStream(); os.write(outputStr.getBytes(&quot;utf-8&quot;)); os.close(); &#125; // 读取服务器端返回的内容 InputStream is = conn.getInputStream(); InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;); BufferedReader br = new BufferedReader(isr); buffer = new StringBuffer(); String line = null; while ((line = br.readLine()) != null) &#123; buffer.append(line); &#125; br.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return buffer.toString(); &#125; public static String urlEncodeUTF8(String source) &#123; String result = source; try &#123; result = java.net.URLEncoder.encode(source, &quot;UTF-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return result; &#125; /** * 解析xml,返回第一级元素键值对。如果第一级元素有子节点，则此节点的值是子节点的xml数据。 * * @param strxml * @return * @throws org.jdom2.JDOMException * @throws IOException */ public static Map doXMLParse(String strxml) throws Exception &#123; if (null == strxml || &quot;&quot;.equals(strxml)) &#123; return null; &#125; Map m = new HashMap(); InputStream in = String2Inputstream(strxml); SAXBuilder builder = new SAXBuilder(); Document doc = builder.build(in); Element root = doc.getRootElement(); List list = root.getChildren(); Iterator it = list.iterator(); while (it.hasNext()) &#123; Element e = (Element) it.next(); String k = e.getName(); String v = &quot;&quot;; List children = e.getChildren(); if (children.isEmpty()) &#123; v = e.getTextNormalize(); &#125; else &#123; v = getChildrenText(children); &#125; m.put(k, v); &#125; //关闭流 in.close(); return m; &#125; /** * 获取子结点的xml * * @param children * @return String */ public static String getChildrenText(List children) &#123; StringBuffer sb = new StringBuffer(); if (!children.isEmpty()) &#123; Iterator it = children.iterator(); while (it.hasNext()) &#123; Element e = (Element) it.next(); String name = e.getName(); String value = e.getTextNormalize(); List list = e.getChildren(); sb.append(&quot;&lt;&quot; + name + &quot;&gt;&quot;); if (!list.isEmpty()) &#123; sb.append(getChildrenText(list)); &#125; sb.append(value); sb.append(&quot;&lt;/&quot; + name + &quot;&gt;&quot;); &#125; &#125; return sb.toString(); &#125; public static InputStream String2Inputstream(String str) &#123; return new ByteArrayInputStream(str.getBytes()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157controller@Api(tags = &quot;支付模块&quot;)@RestController@RequestMapping(&quot;&quot;)public class PayController &#123; @ApiOperation(value = &quot;请求支付接口&quot;) @RequestMapping(value = &quot;/wxPay&quot;, method = RequestMethod.POST) public JSONObject wxPay(HttpServletRequest request) &#123; try &#123; //生成的随机字符串 String nonce_str = getRandomStringByLength(32); //商品名称 String body = &quot;测试商品名称&quot;; //获取客户端的ip地址 String spbill_create_ip = getIpAddr(request); //组装参数，用户生成统一下单接口的签名 Map&lt;String, String&gt; packageParams = new HashMap&lt;&gt;(); packageParams.put(&quot;appid&quot;, WechatConfig.appid); packageParams.put(&quot;mch_id&quot;, WechatConfig.mch_id); packageParams.put(&quot;nonce_str&quot;, nonce_str); packageParams.put(&quot;body&quot;, body); packageParams.put(&quot;out_trade_no&quot;, payOrderId + &quot;&quot;);//商户订单号,自己的订单ID packageParams.put(&quot;total_fee&quot;, 100 + &quot;&quot;);//支付金额，这边需要转成字符串类型，否则后面的签名会失败 packageParams.put(&quot;spbill_create_ip&quot;, spbill_create_ip); packageParams.put(&quot;notify_url&quot;, WechatConfig.notify_url);//支付成功后的回调地址 packageParams.put(&quot;trade_type&quot;, WechatConfig.TRADETYPE);//支付方式 packageParams.put(&quot;openid&quot;, openId + &quot;&quot;);//用户的openID，自己获取 String prestr = PayUtil.createLinkString(packageParams); // 把数组所有元素，按照“参数=参数值”的模式用“&amp;”字符拼接成字符串 //MD5运算生成签名，这里是第一次签名，用于调用统一下单接口 String mysign = PayUtil.sign(prestr, WechatConfig.key, &quot;utf-8&quot;).toUpperCase(); //拼接统一下单接口使用的xml数据，要将上一步生成的签名一起拼接进去 String xml = &quot;&lt;xml&gt;&quot; + &quot;&lt;appid&gt;&quot; + WechatConfig.appid + &quot;&lt;/appid&gt;&quot; + &quot;&lt;body&gt;&lt;![CDATA[&quot; + body + &quot;]]&gt;&lt;/body&gt;&quot; + &quot;&lt;mch_id&gt;&quot; + WechatConfig.mch_id + &quot;&lt;/mch_id&gt;&quot; + &quot;&lt;nonce_str&gt;&quot; + nonce_str + &quot;&lt;/nonce_str&gt;&quot; + &quot;&lt;notify_url&gt;&quot; + WechatConfig.notify_url + &quot;&lt;/notify_url&gt;&quot; + &quot;&lt;openid&gt;&quot; + openid + &quot;&lt;/openid&gt;&quot; + &quot;&lt;out_trade_no&gt;&quot; + payOrderId + &quot;&lt;/out_trade_no&gt;&quot; + &quot;&lt;spbill_create_ip&gt;&quot; + spbill_create_ip + &quot;&lt;/spbill_create_ip&gt;&quot; + &quot;&lt;total_fee&gt;&quot; + 100 + &quot;&lt;/total_fee&gt;&quot;//支付的金额，单位：分 + &quot;&lt;trade_type&gt;&quot; + WechatConfig.TRADETYPE + &quot;&lt;/trade_type&gt;&quot; + &quot;&lt;sign&gt;&quot; + mysign + &quot;&lt;/sign&gt;&quot; + &quot;&lt;/xml&gt;&quot;; //调用统一下单接口，并接受返回的结果 String result = PayUtil.httpRequest(WechatConfig.pay_url, &quot;POST&quot;, xml); // 将解析结果存储在HashMap中 Map map = PayUtil.doXMLParse(result); String return_code = (String) map.get(&quot;return_code&quot;);//返回状态码 String result_code = (String) map.get(&quot;result_code&quot;);//返回状态码 Map&lt;String, Object&gt; response = new HashMap&lt;String, Object&gt;();//返回给小程序端需要的参数 if (return_code == &quot;SUCCESS&quot; &amp;&amp; return_code.equals(result_code)) &#123; String prepay_id = (String) map.get(&quot;prepay_id&quot;);//返回的预付单信息 response.put(&quot;nonceStr&quot;, nonce_str); response.put(&quot;package&quot;, &quot;prepay_id=&quot; + prepay_id); Long timeStamp = System.currentTimeMillis() / 1000; response.put(&quot;timeStamp&quot;, timeStamp + &quot;&quot;);//这边要将返回的时间戳转化成字符串，不然小程序端调用wx.requestPayment方法会报签名错误 //拼接签名需要的参数 String stringSignTemp = &quot;appId=&quot; + WechatConfig.appid + &quot;&amp;nonceStr=&quot; + nonce_str + &quot;&amp;package=prepay_id=&quot; + prepay_id + &quot;&amp;signType=MD5&amp;timeStamp=&quot; + timeStamp; //再次签名，这个签名用于小程序端调用wx.requesetPayment方法 String paySign = PayUtil.sign(stringSignTemp, WechatConfig.key, &quot;utf-8&quot;).toUpperCase(); response.put(&quot;paySign&quot;, paySign); &#125; response.put(&quot;appid&quot;, WechatConfig.appid); return Response.succ(response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; //这里是支付回调接口，微信支付成功后会自动调用 @RequestMapping(value = &quot;/wxNotify&quot;, method = RequestMethod.POST) public void wxNotify(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; BufferedReader br = new BufferedReader(new InputStreamReader(request.getInputStream())); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; sb.append(line); &#125; br.close(); //sb为微信返回的xml String notityXml = sb.toString(); String resXml = &quot;&quot;; Map map = PayUtil.doXMLParse(notityXml); String returnCode = (String) map.get(&quot;return_code&quot;); if (&quot;SUCCESS&quot;.equals(returnCode)) &#123; //验证签名是否正确 Map&lt;String, String&gt; validParams = PayUtil.paraFilter(map); //回调验签时需要去除sign和空值参数 String prestr = PayUtil.createLinkString(validParams); //根据微信官网的介绍，此处不仅对回调的参数进行验签，还需要对返回的金额与系统订单的金额进行比对等 if (PayUtil.verify(prestr, (String) map.get(&quot;sign&quot;), WechatConfig.key, &quot;utf-8&quot;)) &#123; /**此处添加自己的业务逻辑代码start**/ //注意要判断微信支付重复回调，支付成功后微信会重复的进行回调 /**此处添加自己的业务逻辑代码end**/ //通知微信服务器已经支付成功 resXml = &quot;&lt;xml&gt;&quot; + &quot;&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;&quot; + &quot;&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;&quot; + &quot;&lt;/xml&gt; &quot;; &#125; &#125; else &#123; resXml = &quot;&lt;xml&gt;&quot; + &quot;&lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;&quot; + &quot;&lt;return_msg&gt;&lt;![CDATA[报文为空]]&gt;&lt;/return_msg&gt;&quot; + &quot;&lt;/xml&gt; &quot;; &#125; BufferedOutputStream out = new BufferedOutputStream( response.getOutputStream()); out.write(resXml.getBytes()); out.flush(); out.close(); &#125; //获取随机字符串 private String getRandomStringByLength(int length) &#123; String base = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;; Random random = new Random(); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; length; i++) &#123; int number = random.nextInt(base.length()); sb.append(base.charAt(number)); &#125; return sb.toString(); &#125; //获取IP private String getIpAddr(HttpServletRequest request) &#123; String ip = request.getHeader(&quot;X-Forwarded-For&quot;); if (StringUtils.isNotEmpty(ip) &amp;&amp; !&quot;unKnown&quot;.equalsIgnoreCase(ip)) &#123; //多次反向代理后会有多个ip值，第一个ip才是真实ip int index = ip.indexOf(&quot;,&quot;); if (index != -1) &#123; return ip.substring(0, index); &#125; else &#123; return ip; &#125; &#125; ip = request.getHeader(&quot;X-Real-IP&quot;); if (StringUtils.isNotEmpty(ip) &amp;&amp; !&quot;unKnown&quot;.equalsIgnoreCase(ip)) &#123; return ip; &#125; return request.getRemoteAddr(); &#125;&#125; 注意点 notify_url规则 上面的notify_url是微信支付成功时自动调用的回调方法所以一定要是能够直接访问的 notify_url必须是直接请求的 方式是POST 不能有参数不能有访问控制 详见微信文档 这里的回调由于不保证成功所以微信服务器可能存在多次重复调用需要在业务逻辑中判断 这里的参数排序、xml编码等不符合规范都可能出错 这里罗列一种问题 签名错误 可能是secret和密钥混淆导致参数错误上传 可能body参数含有中文字符 或者编码格式有误 支付回调支付退款退款说明 退款文档地址→申请退款 退款接口 https://api.mch.weixin.qq.com/secapi/pay/refund 退款需要双向证书，上面退款文档地址内有相应的说明 退款实现逻辑与付款的不同之处 退款时除请求地址不同外 还需要携带证书参数 代码实现请注意，支付的controller部分的xml组成，参数组成都是可重用的，这里需要在util去新增带证书请求的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647payUtil添加方法public static String doRefund(String mchId, String url, String data) throws Exception &#123; /** * 注意PKCS12证书 是从微信商户平台-》账户设置-》 API安全 中下载的 */ KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;); //这里自行实现我是使用数据库配置将证书上传到了服务器可以使用 FileInputStream读取本地文件 Resource resource = new ClassPathResource(&quot;static/apiclient_cert.p12&quot;); File sourceFile = resource.getFile();// ClassPathResource classPathResource = new ClassPathResource(&quot;/static/apiclient_cert.p12&quot;); FileInputStream inputStream = new FileInputStream(String.valueOf(sourceFile)); try &#123; //这里写密码..默认是你的MCHID keyStore.load(inputStream, mchId.toCharArray()); &#125; finally &#123; inputStream.close(); &#125; SSLContext sslcontext = SSLContexts.custom() //这里也是写密码的 .loadKeyMaterial(keyStore, mchId.toCharArray()) .build(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory( sslcontext, SSLConnectionSocketFactory.getDefaultHostnameVerifier()); CloseableHttpClient httpclient = HttpClients.custom() .setSSLSocketFactory(sslsf) .build(); try &#123; HttpPost httpost = new HttpPost(url); httpost.setEntity(new StringEntity(data, &quot;UTF-8&quot;)); CloseableHttpResponse response = httpclient.execute(httpost); try &#123; HttpEntity entity = response.getEntity(); //接受到返回信息 String jsonStr = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;); EntityUtils.consume(entity); return jsonStr; &#125; finally &#123; response.close(); &#125; &#125; finally &#123; httpclient.close(); &#125; &#125; 注意点签名错误 这里的签名错误同样可能是参数没用按照ASCII码排序导致的 可以通过官方的测试工具调整判断是否满足条件→验证格式 这里的回调参数需要网址形式 ip好像不能通过 余额提现end还有些功能没有总结 后期补充]]></content>
      <categories>
        <category>支付</category>
      </categories>
      <tags>
        <tag>微信支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux部署项目及基础环境配置]]></title>
    <url>%2F2019%2F10%2F29%2Flinux%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[记录一下关于linux服务器的项目环境安装和部署 所选环境CentOS6.8+JDK8+MySQL+Tomcat 安装server端MySQL使用yum命令安装MySQL yum install -y mysql mysql-server 等待安装完成MySQL部分就基本安装完成了，但是此时的MySQL默认是只有本机(locathost)能够连接的，在终端登陆MySQL修改远程连接的SQL； mysql&gt;select host,user from mysql.user;mysql&gt;update user set host=&#39;%&#39; where user=&#39;root&#39; and host=&#39;127.0.0.1&#39;;然后刷新MySQL,然后就可以远程连接了mysql&gt;flush privileges; 安装JDK解压JDK的压缩包tar -zxf jdk-xx-xxx...vi /etc/profile 配置jdk环境变量 export JAVA_HOME=pwd得到的jdk路径exprot PATH=$PATH:$JAVA_HOME/bin配置好后刷新profile文件配置 -&gt;source /etc/profile配置时注意等号两边不要有空格不然会出现乱七八糟的报错 刷新后输入java-version出现了熟悉的版本号命令行 部署Tomcat同jdk第一步，解压后apache目录中有很多文件 要运行的war包要放入webapps中，默认运行的项目名为ROOT；bin目录中负责apache的启动和停止 启动→./startup.sh 停止→./shutdown.sh 启动后通过tail命令查看日志，如无报错 即可正常访问 tail -f logs/catalina.out 查看tomcat的日志 注意事项1.mysql和tomcat的端口都需要在iptables文件中增加，否则远程连接和访问8080时会出现无法连接 vi /etc/sysconfig/iptables-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT-A INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT刷新配置文件 -&gt; service iptables restart这里需要注意 新增的端口信息一定要在icmp-host-prohibited之前 2.可能存在端口占用 netstat -nltp | grep 端口号 然后kill掉进程号即可 3.上图问题是没有开启mysql服务，可以是设置自启也可以运行以下命令 service mysqld start 关于压缩包关于上传相应压缩包，可以使用ftp也可以通过yum源安装工具 yum install -y lrzsz rz上传 sz下载 end基础就是这些，其他负载啥的以后填坑]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>环境部署</tag>
        <tag>Linux操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序初体验]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[微信小程序已经出现很久，长听说却没有上手学习，听说要求严格且繁杂众说纷纭，最近正好有学习，记录一番 介绍微信小程序的介绍→微信小程序 开发异同1.开发工具 在开放工具上小程序使用了特有的微信开发者工具2.布局差异 小程序拥有自己特殊的文本标记语言小程序的写法与Vue相似，基本与web的变化不大，微信小程序为了方便开发者还设计了云开发用来设计服务端（下次使用到再记录） 相关文档及发布 开发之前需要了解其组成，文档当然是→官方文档 小程序的发布很严格，部分类目对个人是不开放的，需要相关的资质 end小技巧:在app.json中输入将要编写的文件名称，会快速生成wxml、wxss，js、json文件 补充(一)补充一个navigat传递参数值过长的问题，此类参数诸如url等等，这是会因为参数过长无法直接传递(接收后不完整)，可通过navigateTo传递； wx.navigateTo({// 传递时通过encodeURIComponent编码传送 url: &apos;../details/details?id=&apos; + encodeURIComponent(id) }); onLoad(options) {// 接收时解码即可 var id = decodeURIComponent(options.id); }]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记od的一次使用]]></title>
    <url>%2F2019%2F06%2F02%2F%E8%AE%B0od%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首次使用od记录一下，临时需要用到，只能临阵磨枪 ##简单认识使用之前首先要认识它的界面具体作用以及一些基础指令在反汇编窗口能够看到想要的东西，然后进行操作比如跳过注册步骤，找到后在数据窗口可以修改相应的数据内容使用的是二进制，因为首次使用所以其他窗口没怎么用到不太了解，再说说基本的OD汇编指令 OD汇编指令 相关说明 NOP 无操作 PUSH 将数据压如堆栈中 POP 出栈（与PUSH相反） JE或者JZ 若相等则跳；如果零标志位Z不为0则跳转,即,要求操作的结果为零 JNE或JNZ 若不等则跳转；如果零标志位Z为0则跳转,即,要求操作的结果非零 CALL 是指将转移到指定的子程序处,它的操作数就是给定的地址 相关汇编指令还有很多，百度一下你就知道 ##实践碰到问题以及技巧1.修改未生效–这个主要是因为保存的问题，OD的保存是”右键”–”复制到可执行文件”然后在保存文件2.找到数据后快速同步定位数据到数据窗口，在反编译窗口右键单击要修改的数据 ##demo实例具体的实例就不记录了，记录一个demo的地址→用OD破解注册过程 ##end 以上描述的都是关于未加壳的OD汇编描述，加壳需要先脱壳 如果修改文字内容字符不够，需要在编辑时将多于空位补零填满 补充换行符:0D0A]]></content>
      <categories>
        <category>OD汇编</category>
      </categories>
      <tags>
        <tag>休闲娱乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter进阶]]></title>
    <url>%2F2019%2F05%2F31%2Fflutter%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[终于学完了Flutter的基础组件，并且实例了一把，感觉光玩组件就很有趣，期待接下来去学习与后台对接成为灵活的App,那么在实践过程中..又踩坑了，记录一下 ##关于报错在学习的过程中出现了这样一个报错 RangeError (index): Invalid value: Valid value range is empty: 0 怎么可能是我出错呢(小声哔哔)，查阅百度这个错误触发的原因是因为构建失败，之后在终端运行 flutter clean 在重新跑项目 成功解决 ##关于打包写完以后想要看看真机是啥效果，于是乎就需要打包，但是在打包之前需要修改几处代码才能够打包成功1.需要有key.jks密钥 AndroidStudio的bin目录位置\keytool -genkey -v -keystore 存放密钥的位置\key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 之后需要填key、pwd等一系列内容然后就能够生成 2.需要在项目中将密钥添入供项目读取先创建/android/key.properties 存放key的相关信息 storePassword=&lt;创建keystore时的storePassword&gt;keyPassword=&lt;创建keystore时的keyPassword&gt;keyAlias=keystoreFile=&lt;密钥库文件的位置 , 例如: /Users//key.jks&gt; 然后/android/app/build.gradle 找到 android { 在这行之前添加如下代码 def keystorePropertiesFile = rootProject.file(“key.properties”)def keystoreProperties = new Properties()keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) 然后把buildType{}替换一段代码 signingConfigs { release { keyAlias keystoreProperties[‘keyAlias’] keyPassword keystoreProperties[‘keyPassword’] storeFile file(keystoreProperties[‘storeFile’]) storePassword keystoreProperties[‘storePassword’] } } buildTypes { release { signingConfig signingConfigs.release } } 这样就配置完成了，然后运行 flutter build run 就可以正常打包了 ##endstoreFile的路径要填写绝对路径，生成的密钥不要共享和泄露打包完的apk文件在 /build/app/outputs/apk/app-release.apk]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>small case</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次flutter无限踩坑爬坑的历程]]></title>
    <url>%2F2019%2F05%2F09%2Fflutter%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[简介Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。Flutter百度百科 安装 工欲善其事，必先利其器 &nbsp;安装必不可少，坑也不能少 想要正常使用flutter,需要经历以下几个步骤 Flutter SDK &nbsp;下载地址 flutter配置path需要指向到flutter文件夹的bin目录 2.Android SDK+开发工具 Android Studio下载地址使用vs code、idea开发可以直接安装sdk(已安装过的 需要配置环境变量供flutter检测)3.配置环境变量+ide绑定环境路径(下图为sdk位置配置)(ide就不记录了,都是setting&gt;&gt;&gt;plugins先down下来 然后配置)正常到这里就结束了,然后重启,在命令行中输入 flutter doctor -v 进行检测 (感叹号是没用连接可用模拟器) &nbsp;出现上图即代表安装成功后面几个ide检测可以根据自己的需求来,不正常就可能会出现如下情况(主要说说Android toolchain项出现的问题) ✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ (没有检测到sdk的环境变量 ) 看上图正常情况下ANDROID_HOME的环境配置 2.✗ Android license status unknown. （更新sdk） 执行flutter doctor –android-licenses 返回如下内容： A newer version of the Android SDK is required. To update, run: 此处是你AndroidSdk安装目录/tools/bin/sdkmanager –update 执行run后的内容即可 3.Exception in thread “main” java.lang.UnsupportedClassVersionError 这里时jdk的问题 输入java -version查看版本 仅支持1.8+版本 4.证书问题 sdk license available flutter doctor –android-licenses 然后一直选择y即可 虚拟化冲突在使用开始前还需要做一个准备,需要安装AVD虚拟机,也就是模拟机,这时候出现了新的问题这个问题是因为之前安装docker需要开启hyper-v，而AVD需要HAXM的支持，两种同为虚拟化扩展，所以会造成冲突。百度了一下 Window10同时使用Docker Hyper-v和Android模拟器,重启后打开ide，avd完美运行。 Hello Flutter全部配置都完工了，Hello一波 end一次繁琐而又刺激的安装，虽然过程艰难，但是也算收获满满，后续碰到问题和解决办法会补充在end里新收获:写Flutter的时候一定记着,万物皆组件((^_^))补充:关于as在3.x安装没有SDK选项的记录→安装Android Studio时没有Sdk选项]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go初体验]]></title>
    <url>%2F2019%2F04%2F15%2Fgo%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[概述最近突然有被go刷屏的感觉,带着好奇心了解了go,得知go被众多开发者和大牛选择的原因如下: 可学习度高(容易上手)&nbsp;&nbsp;&nbsp;&nbsp; 开发效率高 方便部署、稳定性&nbsp;&nbsp;&nbsp;&nbsp; 并发能力原因还有很多,心动ing,决定仔细了解一番,没有从教程中感觉到go具体用途0.0(看来学习前还要了解它的作用) go能做什么Go语言主要用于开发服务端,其定位也是开发”大型软件”的,适合多人协作、便于开发和后期维护。主要适用于web、api等开发 安装go环境go环境下载地址下载对于版本安装,安装完成后在终端输入 go env 出现很多信息即为安装成功了 hello go环境安好后在任意目录创建hello.go文件 文件内容如下 package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello, go!&quot;) } 在该目录下运行 go run hello.go 得到如下结果 Hello, go! ##end如环境安装失败注意path是否配置]]></content>
  </entry>
  <entry>
    <title><![CDATA[Dubbo入门体验]]></title>
    <url>%2F2019%2F04%2F01%2FDubbo%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介Dubbo 是阿里巴巴开源项目的一个分布式服务框架。其致力于提供高性能和透明化的 RPC 远程调用方案，以及 SOA 服务治理方案。 原理由图可见dubbo主要由服务提供者、注册中心、服务消费者、监控中心和容器组成 节点 角色说明 Container 服务运行容器 Provider 暴露服务的服务提供者 Consumer 调用远程服务的服务消费者 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用此处和调用时间的监控中心 过程如上图所示 服务运行容器启动、加载运行服务提供者 服务提供者启动时将服务提供给注册中心 服务消费者启动时向注册中心订阅需要的服务 注册中心返回服务提供者信息列表给消费者 服务消费者从列表中,基于软负载均衡选一台服务提供者进行调用，如果调用失败再选另一台 服务消费者和服务提供者在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心具体实现在网上找了很久demo多数写的不够全面,找了很久才找到了一个较为详细的,项目是maven聚合项目,通过api、服务提供者、服务消费者三个model构成,注册中心使用zookeeper单体zookeeper-Windows安装教程,demo具体实现→dubbo-demo补充在dubbo官网上还有服务、集群、负载均衡等知识供学习Dubbo官网,这些可以在dubbo-admin中控制dubbo-admin]]></content>
  </entry>
  <entry>
    <title><![CDATA[docker入门]]></title>
    <url>%2F2019%2F03%2F28%2Fdocker%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介docker容器采用c/s架构,使用镜像来创建容器,使用远程api来管理容器&gt;&gt;&gt;docker简介 应用场景某个系统的技术栈非常广就会需要依赖于各种开源库和中间件,如果需要多次部署,那么版本控制、依赖管理就会相对复杂,docker只需要根据应用程序的部署步骤编写一份Dockerfile文件(将安装、配置等操作交由Docker自动化处理),然后构建并发布他的镜像,这样,不管在什么机器上都只需要拉取需要的镜像,然后就可以直接部署运行 生命周期docker分为三部分,理解其作用也就了解了生命周期,docker分为镜像、容器、仓库 镜像是Docker生命周期中的构建或打包阶段，容器则是启动或执行阶段 安装mac和Linux可以流畅安装,windows需要看版本,专业版流畅,家庭版需要执行命令开启Hyper-V和修改注册表,参考→windows家庭版安装docker 基础命令docker 查看所有命令 docker images 列出本地镜像 docker pull 从镜像仓库中拉取或者更新指定镜像 docker ps 列出正在运行的容器... 实现docker run hello-world 能够看到控制台打印hello world就成功了 end docker在后期使用过程中拉去镜像极慢,可以在docker-&gt;setting中采用国内镜像加速 https://registry.docker-cn.com 中文镜像加速网址 dockerfile适合安装多个镜像自动化时使用,单个推荐直接安装 补充dockerfile创建dockerfil文件 type nul&gt;DockerfileName dockerfile内容如下 #基于 node 镜像 FROM node #指定维护者信息 MAINTAINER xx xxx@xx.com #指定下一条命令的运行目录 WORKDIR /usr/local #新建路径 RUN mkdir work #在 /usr/local 的基础上指定运行目录，所以当前目录为：/usr/local/work WORKDIR work #安装必要的组件 RUN npm install express RUN npm install express-generator -g RUN npm install supervisor -g RUN express myapp -e #将当前目录下的文件，复制到 /usr/local/work/ 下 #COPY . /usr/local/work/ WORKDIR /usr/local/work/myapp RUN npm install WORKDIR /usr/local/work/myapp #启动 express 应用 CMD supervisor ./bin/www #暴露容器 3000 端口 EXPOSE 3000 docker build -t imagename . （在dockerfile所在目录运行创建镜像 .号是指定 dockerfile 在当前目录中）docker run -p 4000:3000 imagename (映射到宿主机) *dockerfile取于使用 Dockerfile 自定义 Docker 镜像]]></content>
  </entry>
  <entry>
    <title><![CDATA[mongoDB初体验]]></title>
    <url>%2F2019%2F03%2F24%2FMongoDB%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[mongodb是非关系型数据库的一种… 还是看百度吧 →百度百科,在首次使用中安装和运行上出现了些小问题,记录一下以便下一次查阅 mongo与关系型数据库的区别相较于关系型各有优缺点 安装MongoDB安装过程非常easy 不要对坑跳就ok,安装时记得取消掉下图的√ 启动MongoDB服务首先要去了解MongoDB的基础语法…百度吧…这里我参考了网上的教程步骤如下： 创建一个文件夹存放MongoDB的脚本（mkdir db） 在MongoDB的bin目录里启动cmd,然后执行命令F:\MongoDB\Server\4.0\bin&gt;mongod --dbpath=F:\db然后就能启动服务了(^_^),MongoDB启动后将占用端口27017,如下图可视化工具由于命令比较麻烦,这里我选用了GUI工具,选择了RoboMongo官网链接,操作非常easy,简单操作可以参考这篇教程RoboMongo简单操作介绍 endMongoDB的连接有可能会出现断连的情况,不过应该极少,这点需要注意一下︿(￣︶￣)︿]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决MySql存入特殊符号乱码问题]]></title>
    <url>%2F2019%2F03%2F23%2FMySql%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[之前偶然发现后台处理带有特殊符号的字符串无法存入数据库,并且程序报错Incorrect string value: &#39;\xF0\x9F\xA4\x97 3...&#39; for column &#39;nick_name&#39; at row 1 乱码原因分析emoji表情符采用Unicode 6标准 一个emoji存储需要占用4个byte字节存储,而mysql采用utf-8编码时采用3个byte字节存储一个字符,所以导致无法存入 了解了原因之后就可以着手解决了,这个问题可以着手从两方面解决 修改数据库编码 修改代码 修改数据库编码修改数据库编码比较简单,可以将utf-8修改为utf8mb4 然后重启数据库再次存储就不会报错了 但是数据库内emoji显示为乱码无法查看 修改代码 过滤特殊字符后存入,弊端:内容不齐全如果全是emoji将会显示为空nickname.replaceAll(&quot;[\ue000-\uefff]&quot;,&quot;&quot;); 对含有特殊字符的字符串进行加解密处理,弊端:数据库内看到的内容为编码字符,显示时需要解码 12345String nickname = &quot;LemonQi&quot;;if(nickname != null)&#123; String a =Base64.encodeBase64String(nickname.getBytes(&quot;UTF-8&quot;));//进行编码 String a = new String(Base64.decodeBase64(nickname), &quot;UTF-8&quot;);//进行解码&#125; end每修改的方式都有一定的弊端,需要就业务逻辑来进行使用,就编码解码而言相对谨慎能够保持其完整性,以上就是个人使用感觉的记录了(^_^)]]></content>
  </entry>
  <entry>
    <title><![CDATA[初探Vue+axios]]></title>
    <url>%2F2019%2F03%2F22%2FVueAndAxios%2F</url>
    <content type="text"><![CDATA[因为不太懂前端所以一开始只了解div+css,后来慢慢听别人提起Vue、Angular、React,才开始了解前端框架，首次体验Vue发现相较于div+css有了明显的便利感操作十分简单,为Vue打call总结一下体验感(^_^) Vue优点 将原来的直接操作dom的思想转变为操作数据,十分方便 操作简单,通过组合、拼凑快速完成页面渲染 axiosaxios的好处就不列举了 太多了(๑•̀ㅂ•́)و✧ 相比ajax,axios则更适合前端mvvm思想,它还能自动转换json数据 这更加适应了前后端分离的开发方式 补充之前有写过一个没有登录态的前后端整合，后来很久没有写前端，最近整合了一个，填一下之前的坑。 关于登录态前后端分离项目 后端在前端发来登录信息时，后端反馈前端一个token 然后前端存储，并在发送需要验证用户的请求时携带 如何存储使用sessionStorage或者localStorage存储，两者的同点时都使用浏览器存储信息，异点在于session显而易见属于会话存储，当会话结束时存储的内容就失效了 具体使用要看业务内容而定 关于局域网测试 修改package.json中script下dev的值，在后面加入–host 0.0.0.0 记录一个失了智的遭遇，局域网内自己电脑能访问手机上发送不出去axios请求，因为设置如下（つ﹏⊂） axios.default.baseUrl =’http://localhost:8080&#39; 以上方式是错误的 要配置成局域网IP end新的坑 下次碰到再记录附一个vscode生成Vue代码模板的快捷方式→传送门]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用JavaMail发送SMTP遇到的坑]]></title>
    <url>%2F2019%2F03%2F21%2FJavaMail%2F</url>
    <content type="text"><![CDATA[添加maven依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 添加properties配置#email 配置 spring.mail.host=smtp.xxx.com spring.mail.username=xxxxxxx@163.com //此处password是校验码不是邮箱密码可自行百度 spring.mail.password=xxxxxxxx spring.mail.properties.mail.smtp.starttls.enable=true spring.mail.properties.mail.smtp.port=25 //端口号 spring.mail.default-encoding=UTF-8 添加测试方法@Autowired JavaMailSender mailSender; //自动注入邮件配置 @Value(&quot;${spring.mail.username}&quot;) private String Sender; //读取配置文件中的参数 public String sendSimpleMail(){ SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(Sender); //邮件发送人 //需要多人接收使用list 集合 不需要可以直接使用message的几个方法 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;xxxx@xxx.com&quot;); list.add(&quot;xxx@xxx.com&quot;); for (int i = 0; i &lt; list.size(); i++) { String obj=(String)list.get(i); message.setTo(obj); message.setSubject(&quot;订单&quot;); //邮件主题 message.setText(pd.getString(&quot;message&quot;)+pd.get(&quot;uid&quot;)); //邮件内容 mailSender.send(message); } return &quot;OK&quot;; } 注意事项邮箱开放25/465端口(基本,有些开放其他端口)发送邮件 message.setTo //接收人 message.setCc //抄送人 ... 阿里ecs默认封25端口 可以使用ssl 传输 ssl加密发送邮件修改properties配置 //spring.mail.properties.mail.smtp.port=25 spring.mail.properties.mail.smtp.port=465 添加properties配置: #SSL证书Socket工厂 spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory 使用465 服务器成功发送(^_^)]]></content>
  </entry>
  <entry>
    <title><![CDATA[PowerDesigner踩坑过程]]></title>
    <url>%2F2019%2F03%2F21%2FPowerDesigner%2F</url>
    <content type="text"><![CDATA[1.安装及入门pd16.5下载、破解、汉化教程PowerDesigner最基础的使用方法入门学习 2.小技巧去黑线(强迫症患者)模型默认在黑色线框中显示，影响视觉体验 &lt;br&gt; `Tools→DispalyPreferences 将show page delimiter 取消勾选` sql反向生成模型`File→Reverse Engineer→Database 选择类型选择文件 生成` 导出excel表格文件`选中tables ctrl + shift +x 然后运行脚本（脚本如下）` 补充关于默认值有些列是拥有默认值的比如创建时间和修改时间 再比如主键等，pd的时间设置如下 单击选中column – 右击选择properties Standard Checks页面中的default 如下图 主键则在properties打开后直接在general页面 勾选identity即可 导出excel&apos;****************************************************************************** &apos;* File: pdm2excel.txt &apos;* Title: pdm export to excel &apos;* Purpose: To export the tables and columns to Excel &apos;* Model: Physical Data Model 16.5 , Microsoft Office 2007 &apos;* Objects: Table, Column, View &apos;****************************************************************************** Option Explicit Dim rowsNum rowsNum = 0 &apos;----------------------------------------------------------------------------- &apos; Main function &apos;----------------------------------------------------------------------------- &apos; Get the current active model Dim Model Set Model = ActiveModel If (Model Is Nothing) Or (Not Model.IsKindOf(PdPDM.cls_Model)) Then MsgBox &quot;The current model is not an PDM model.&quot; Else &apos; Get the tables collection &apos;创建EXCEL APP dim beginrow DIM EXCEL, SHEET set EXCEL = CREATEOBJECT(&quot;Excel.Application&quot;) EXCEL.workbooks.add(-4167)&apos;添加工作表 EXCEL.workbooks(1).sheets(1).name =&quot;test&quot; set sheet = EXCEL.workbooks(1).sheets(&quot;test&quot;) ShowProperties Model, SHEET EXCEL.visible = true &apos;设置列宽和自动换行 sheet.Columns(1).ColumnWidth = 20 sheet.Columns(2).ColumnWidth = 40 sheet.Columns(4).ColumnWidth = 20 sheet.Columns(5).ColumnWidth = 20 sheet.Columns(6).ColumnWidth = 15 sheet.Columns(1).WrapText =true sheet.Columns(2).WrapText =true sheet.Columns(4).WrapText =true End If &apos;----------------------------------------------------------------------------- &apos; Show properties of tables &apos;----------------------------------------------------------------------------- Sub ShowProperties(mdl, sheet) &apos; Show tables of the current model/package rowsNum=0 beginrow = rowsNum+1 &apos; For each table output &quot;begin&quot; Dim tab For Each tab In mdl.tables ShowTable tab,sheet Next if mdl.tables.count &gt; 0 then sheet.Range(&quot;A&quot; &amp; beginrow + 1 &amp; &quot;:A&quot; &amp; rowsNum).Rows.Group end if output &quot;end&quot; End Sub &apos;----------------------------------------------------------------------------- &apos; Show table properties &apos;----------------------------------------------------------------------------- Sub ShowTable(tab, sheet) If IsObject(tab) Then Dim rangFlag rowsNum = rowsNum + 1 &apos; Show properties Output &quot;================================&quot; sheet.cells(rowsNum, 1) = &quot;实体名&quot; sheet.cells(rowsNum, 2) =tab.name sheet.cells(rowsNum, 3) = &quot;&quot; sheet.cells(rowsNum, 4) = &quot;表名&quot; sheet.cells(rowsNum, 5) = tab.code sheet.Range(sheet.cells(rowsNum, 5),sheet.cells(rowsNum, 6)).Merge rowsNum = rowsNum + 1 sheet.cells(rowsNum, 1) = &quot;属性名&quot; sheet.cells(rowsNum, 2) = &quot;说明&quot; sheet.cells(rowsNum, 3) = &quot;&quot; sheet.cells(rowsNum, 4) = &quot;字段中文名&quot; sheet.cells(rowsNum, 5) = &quot;字段名&quot; sheet.cells(rowsNum, 6) = &quot;字段类型&quot; &apos;设置边框 sheet.Range(sheet.cells(rowsNum-1, 1),sheet.cells(rowsNum, 2)).Borders.LineStyle = &quot;1&quot; sheet.Range(sheet.cells(rowsNum-1, 4),sheet.cells(rowsNum, 6)).Borders.LineStyle = &quot;1&quot; Dim col &apos; running column Dim colsNum colsNum = 0 for each col in tab.columns rowsNum = rowsNum + 1 colsNum = colsNum + 1 sheet.cells(rowsNum, 1) = col.name sheet.cells(rowsNum, 2) = col.comment sheet.cells(rowsNum, 3) = &quot;&quot; sheet.cells(rowsNum, 4) = col.name sheet.cells(rowsNum, 5) = col.code sheet.cells(rowsNum, 6) = col.datatype next sheet.Range(sheet.cells(rowsNum-colsNum+1,1),sheet.cells(rowsNum,2)).Borders.LineStyle = &quot;2&quot; sheet.Range(sheet.cells(rowsNum-colsNum+1,4),sheet.cells(rowsNum,6)).Borders.LineStyle = &quot;2&quot; rowsNum = rowsNum + 1 Output &quot;FullDescription: &quot; + tab.Name End If End Sub]]></content>
  </entry>
  <entry>
    <title><![CDATA[The first day of blogging]]></title>
    <url>%2F2019%2F03%2F21%2Ffirst%2F</url>
    <content type="text"><![CDATA[这是这个blog存在的第一天记录一下接下来将会记录自己挖坑自己填的流水账、学习等过程(^_^) Hello world！！！]]></content>
      <categories>
        <category>first</category>
      </categories>
  </entry>
</search>
