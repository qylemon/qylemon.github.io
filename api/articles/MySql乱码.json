{"title":"解决MySql存入特殊符号乱码问题","slug":"MySql乱码","date":"2019-03-23T14:11:36.865Z","updated":"2020-02-15T06:21:05.477Z","comments":true,"path":"api/articles/MySql乱码.json","excerpt":"之前偶然发现后台处理带有特殊符号的字符串无法存入数据库,并且程序报错<br>Incorrect string value: &#39;\\xF0\\x9F\\xA4\\x97 3...&#39; for column &#39;nick_name&#39; at row 1","covers":null,"content":"<p>之前偶然发现后台处理带有特殊符号的字符串无法存入数据库,并且程序报错<br><code>Incorrect string value: &#39;\\xF0\\x9F\\xA4\\x97 3...&#39; for column &#39;nick_name&#39; at row 1</code></p>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"乱码原因分析\"><a href=\"#乱码原因分析\" class=\"headerlink\" title=\"乱码原因分析\"></a>乱码原因分析</h2><p>emoji表情符采用Unicode 6标准 一个emoji存储需要占用4个byte字节存储,而mysql采用utf-8编码时采用3个byte字节存储一个字符,所以导致无法存入</p>\n<hr>\n<p>了解了原因之后就可以着手解决了,这个问题可以着手从两方面解决<br></p>\n<ol>\n<li>修改数据库编码<br></li>\n<li>修改代码 </li>\n</ol>\n<h2 id=\"修改数据库编码\"><a href=\"#修改数据库编码\" class=\"headerlink\" title=\"修改数据库编码\"></a>修改数据库编码</h2><p>修改数据库编码比较简单,可以将utf-8修改为utf8mb4 然后重启数据库再次存储就不会报错了 但是数据库内emoji显示为乱码无法查看</p>\n<h2 id=\"修改代码\"><a href=\"#修改代码\" class=\"headerlink\" title=\"修改代码\"></a>修改代码</h2><ol>\n<li>过滤特殊字符后存入,弊端:内容不齐全如果全是emoji将会显示为空<br><br><code>nickname.replaceAll(&quot;[\\ue000-\\uefff]&quot;,&quot;&quot;);</code></li>\n<li>对含有特殊字符的字符串进行加解密处理,弊端:数据库内看到的内容为编码字符,显示时需要解码<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String nickname = &quot;LemonQi&quot;;</span><br><span class=\"line\">if(nickname != null)&#123;</span><br><span class=\"line\">\tString a =Base64.encodeBase64String(nickname.getBytes(&quot;UTF-8&quot;));//进行编码</span><br><span class=\"line\">\tString a = new String(Base64.decodeBase64(nickname), &quot;UTF-8&quot;);//进行解码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2><p>每修改的方式都有一定的弊端,需要就业务逻辑来进行使用,就编码解码而言相对谨慎能够保持其完整性,以上就是个人使用感觉的记录了(<em>^_^</em>)</p>\n","more":"<hr>\n<h2 id=\"乱码原因分析\"><a href=\"#乱码原因分析\" class=\"headerlink\" title=\"乱码原因分析\"></a>乱码原因分析</h2><p>emoji表情符采用Unicode 6标准 一个emoji存储需要占用4个byte字节存储,而mysql采用utf-8编码时采用3个byte字节存储一个字符,所以导致无法存入</p>\n<hr>\n<p>了解了原因之后就可以着手解决了,这个问题可以着手从两方面解决<br></p>\n<ol>\n<li>修改数据库编码<br></li>\n<li>修改代码 </li>\n</ol>\n<h2 id=\"修改数据库编码\"><a href=\"#修改数据库编码\" class=\"headerlink\" title=\"修改数据库编码\"></a>修改数据库编码</h2><p>修改数据库编码比较简单,可以将utf-8修改为utf8mb4 然后重启数据库再次存储就不会报错了 但是数据库内emoji显示为乱码无法查看</p>\n<h2 id=\"修改代码\"><a href=\"#修改代码\" class=\"headerlink\" title=\"修改代码\"></a>修改代码</h2><ol>\n<li>过滤特殊字符后存入,弊端:内容不齐全如果全是emoji将会显示为空<br><br><code>nickname.replaceAll(&quot;[\\ue000-\\uefff]&quot;,&quot;&quot;);</code></li>\n<li>对含有特殊字符的字符串进行加解密处理,弊端:数据库内看到的内容为编码字符,显示时需要解码<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String nickname = &quot;LemonQi&quot;;</span><br><span class=\"line\">if(nickname != null)&#123;</span><br><span class=\"line\">\tString a =Base64.encodeBase64String(nickname.getBytes(&quot;UTF-8&quot;));//进行编码</span><br><span class=\"line\">\tString a = new String(Base64.decodeBase64(nickname), &quot;UTF-8&quot;);//进行解码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2><p>每修改的方式都有一定的弊端,需要就业务逻辑来进行使用,就编码解码而言相对谨慎能够保持其完整性,以上就是个人使用感觉的记录了(<em>^_^</em>)</p>","categories":[],"tags":[]}