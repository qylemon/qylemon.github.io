{"title":"memcached入门与应用","slug":"memcached入门与应用","date":"2019-12-12T15:48:02.000Z","updated":"2019-12-18T05:17:06.660Z","comments":true,"path":"api/articles/memcached入门与应用.json","excerpt":" [Figure] ","covers":["https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c31f35c5f6f17f894b4ba10d37d5d3d0c877e6abe5ac9262b2373ddf57cddadbbb4cc1075ce74b9e2554ae8c9e567fda?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=1643994375&amp;fname=u%3D1662290941%2C822820676%26fm%3D26%26gp%3D0.jpg&amp;size=750"],"content":"<p><img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c31f35c5f6f17f894b4ba10d37d5d3d0c877e6abe5ac9262b2373ddf57cddadbbb4cc1075ce74b9e2554ae8c9e567fda?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=1643994375&amp;fname=u%3D1662290941%2C822820676%26fm%3D26%26gp%3D0.jpg&amp;size=750\" alt><br><a id=\"more\"></a></p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>是一款高性能、分布式的内存对象缓存系统可以有效地分担数据库负载，基于libevent事件处理实现无阻塞通信（高性能原因之一），是以key/value键值对形式存储</p>\n<h2 id=\"有什么优势\"><a href=\"#有什么优势\" class=\"headerlink\" title=\"有什么优势\"></a>有什么优势</h2><p>熟悉memcached的童鞋可能知道 一般它都会被和reids进行比较，两者各有千秋，redis支持5种数据类型存储，memcached仅支持key/value；但memcached的性能优于redis。</p>\n<h2 id=\"能干啥\"><a href=\"#能干啥\" class=\"headerlink\" title=\"能干啥\"></a>能干啥</h2><p>使用memcached做缓存可以有效地减轻数据库压力，提高系统性能</p>\n<h2 id=\"关于存储\"><a href=\"#关于存储\" class=\"headerlink\" title=\"关于存储\"></a>关于存储</h2><h3 id=\"底层存储内存分配机制\"><a href=\"#底层存储内存分配机制\" class=\"headerlink\" title=\"底层存储内存分配机制\"></a>底层存储内存分配机制</h3><p>memcached数据最终会存入chunk，分配时通过slab分配器决定的，slabclass会记录slab的信息，每个slab下有无数个等份page，page下有无数个等份chunk，chunk是数据的真实存储单位，默认大小为80byte，slab的大小取决于自增长因子</p>\n<h4 id=\"寻找chunk的过程\"><a href=\"#寻找chunk的过程\" class=\"headerlink\" title=\"寻找chunk的过程\"></a>寻找chunk的过程</h4><p>memcached的删除属于逻辑删除，删除和过期的chunk会标识后放入slot，以供后续存储的空间处理，当在slot中没有找到不用的chunk时，会寻找空闲chunk存储，当两者都不满足时会触发LRU机制，在寻找chunk存储时，不会因为其他slab有空闲就不触发LRU流程</p>\n<h3 id=\"memcached分布式的hash算法\"><a href=\"#memcached分布式的hash算法\" class=\"headerlink\" title=\"memcached分布式的hash算法\"></a>memcached分布式的hash算法</h3><h4 id=\"①余数hash\"><a href=\"#①余数hash\" class=\"headerlink\" title=\"①余数hash\"></a>①余数hash</h4><p>由名可得，这种算法时取余数获得存储的位置，主要是将key值转换为hash值然后除以机器数量取余。此方法有很大缺陷，一旦机器数量变化(增加节点/机器损坏)数据将会失效；</p>\n<h4 id=\"②※一致性hash\"><a href=\"#②※一致性hash\" class=\"headerlink\" title=\"②※一致性hash\"></a>②※一致性hash</h4><p>将服务器列表(真实节点)和虚拟节点分布在一个0-2的32次方的圆上。同样key取hash值，通过余数方式确定存放机器，如果命中的时虚拟节点则顺时针找到下一个真实节点存储。此方法影响更小、易排查</p>\n<h2 id=\"哪儿尬\"><a href=\"#哪儿尬\" class=\"headerlink\" title=\"哪儿尬\"></a>哪儿尬</h2><p>这次没出现啥尬的，安装过程就不记录了。碰到新的方法或问题，下次再记录</p>\n<h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2><p>memcached基于libevent，那么安装也依赖于libevent，所以安装时需要先安装libevent<br><br>memcached可以通过设置CAS或者版本号的方式来避免重复修改</p>\n","more":"</p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>是一款高性能、分布式的内存对象缓存系统可以有效地分担数据库负载，基于libevent事件处理实现无阻塞通信（高性能原因之一），是以key/value键值对形式存储</p>\n<h2 id=\"有什么优势\"><a href=\"#有什么优势\" class=\"headerlink\" title=\"有什么优势\"></a>有什么优势</h2><p>熟悉memcached的童鞋可能知道 一般它都会被和reids进行比较，两者各有千秋，redis支持5种数据类型存储，memcached仅支持key/value；但memcached的性能优于redis。</p>\n<h2 id=\"能干啥\"><a href=\"#能干啥\" class=\"headerlink\" title=\"能干啥\"></a>能干啥</h2><p>使用memcached做缓存可以有效地减轻数据库压力，提高系统性能</p>\n<h2 id=\"关于存储\"><a href=\"#关于存储\" class=\"headerlink\" title=\"关于存储\"></a>关于存储</h2><h3 id=\"底层存储内存分配机制\"><a href=\"#底层存储内存分配机制\" class=\"headerlink\" title=\"底层存储内存分配机制\"></a>底层存储内存分配机制</h3><p>memcached数据最终会存入chunk，分配时通过slab分配器决定的，slabclass会记录slab的信息，每个slab下有无数个等份page，page下有无数个等份chunk，chunk是数据的真实存储单位，默认大小为80byte，slab的大小取决于自增长因子</p>\n<h4 id=\"寻找chunk的过程\"><a href=\"#寻找chunk的过程\" class=\"headerlink\" title=\"寻找chunk的过程\"></a>寻找chunk的过程</h4><p>memcached的删除属于逻辑删除，删除和过期的chunk会标识后放入slot，以供后续存储的空间处理，当在slot中没有找到不用的chunk时，会寻找空闲chunk存储，当两者都不满足时会触发LRU机制，在寻找chunk存储时，不会因为其他slab有空闲就不触发LRU流程</p>\n<h3 id=\"memcached分布式的hash算法\"><a href=\"#memcached分布式的hash算法\" class=\"headerlink\" title=\"memcached分布式的hash算法\"></a>memcached分布式的hash算法</h3><h4 id=\"①余数hash\"><a href=\"#①余数hash\" class=\"headerlink\" title=\"①余数hash\"></a>①余数hash</h4><p>由名可得，这种算法时取余数获得存储的位置，主要是将key值转换为hash值然后除以机器数量取余。此方法有很大缺陷，一旦机器数量变化(增加节点/机器损坏)数据将会失效；</p>\n<h4 id=\"②※一致性hash\"><a href=\"#②※一致性hash\" class=\"headerlink\" title=\"②※一致性hash\"></a>②※一致性hash</h4><p>将服务器列表(真实节点)和虚拟节点分布在一个0-2的32次方的圆上。同样key取hash值，通过余数方式确定存放机器，如果命中的时虚拟节点则顺时针找到下一个真实节点存储。此方法影响更小、易排查</p>\n<h2 id=\"哪儿尬\"><a href=\"#哪儿尬\" class=\"headerlink\" title=\"哪儿尬\"></a>哪儿尬</h2><p>这次没出现啥尬的，安装过程就不记录了。碰到新的方法或问题，下次再记录</p>\n<h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2><p>memcached基于libevent，那么安装也依赖于libevent，所以安装时需要先安装libevent<br><br>memcached可以通过设置CAS或者版本号的方式来避免重复修改</p>","categories":[{"name":"memcached","path":"api/categories/memcached.json"}],"tags":[{"name":"memcached","path":"api/tags/memcached.json"},{"name":"缓存","path":"api/tags/缓存.json"}]}