{"title":"springboot完美跨域","slug":"springboot完美跨域","date":"2019-12-18T06:01:20.000Z","updated":"2019-12-18T07:17:40.200Z","comments":true,"path":"api/articles/springboot完美跨域.json","excerpt":" [Figure] ","covers":["https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/18971a722a724044cf2cadd38cfad72c4682c7d10a73f7c0e0a270a5fa3adc8efd5a4fd0b56bb4d1e9acb7f795b67f34?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=1643994375&amp;fname=u%3D47137405%2C491173432%26fm%3D26%26gp%3D0.jpg&amp;size=750","https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/5453f5d052139390a818050dd5fbaa9397107fd658f8070ab82928cd018b52bc0d8cb6b975ad2d0ef2953aada526ae86?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=1643994375&amp;fname=%E6%A2%AD.jpg&amp;size=750"],"content":"<p><img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/18971a722a724044cf2cadd38cfad72c4682c7d10a73f7c0e0a270a5fa3adc8efd5a4fd0b56bb4d1e9acb7f795b67f34?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=1643994375&amp;fname=u%3D47137405%2C491173432%26fm%3D26%26gp%3D0.jpg&amp;size=750\" alt><a id=\"more\"></a></p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>前后端分离开发的场景已经趋于常态，跨域就必不可少</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">URL</th>\n<th style=\"text-align:center\">说明</th>\n<th style=\"text-align:center\">是否允许通信</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.baidu.com/a.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com/a.js</a><br><a href=\"http://www.baidu.com/b.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com/b.js</a></td>\n<td style=\"text-align:center\">同域</td>\n<td style=\"text-align:center\">允许通讯</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.baidu.com:8080/a.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com:8080/a.js</a><br><a href=\"http://www.baidu.com:8081/b.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com:8081/b.js</a></td>\n<td style=\"text-align:center\">同域不同端口</td>\n<td style=\"text-align:center\">不允许通信(跨域）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.baidu.com/a.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com/a.js</a><br><a href=\"http://www.xxx.com/b.js\" target=\"_blank\" rel=\"noopener\">www.xxx.com/b.js</a></td>\n<td style=\"text-align:center\">不同域</td>\n<td style=\"text-align:center\">不允许通信(跨域）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"有哪些配置方式\"><a href=\"#有哪些配置方式\" class=\"headerlink\" title=\"有哪些配置方式\"></a>有哪些配置方式</h2><p>springboot的跨域一般有两种情况，请求上加注解和统一配置(configration/filter)，像我这样图方便的人就喜欢统一配置，网上的通用配置很多<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/5453f5d052139390a818050dd5fbaa9397107fd658f8070ab82928cd018b52bc0d8cb6b975ad2d0ef2953aada526ae86?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=1643994375&amp;fname=%E6%A2%AD.jpg&amp;size=750\" alt></p>\n<h2 id=\"哪儿尬\"><a href=\"#哪儿尬\" class=\"headerlink\" title=\"哪儿尬\"></a>哪儿尬</h2><p>然而尴尬的事情发生了，前端携带token请求后端接口时被拦截了500，仔细看了请求 发现浏览器在发送真实请求前会发送一个options预请求进行校验需要满足以下条件</p>\n<ul>\n<li>请求方法不是GET/HEAD/POST</li>\n<li>POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain</li>\n<li>请求设置了自定义的header字段</li>\n</ul>\n<p>显然 token并不属于官方请求头 那么就是这个通用失效的原因了，贴上这次使用的代码，下次不尬</p>\n<pre><code>@Bean\npublic FilterRegistrationBean corsFilter() {\n    // 注册CORS过滤器\n    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n    CorsConfiguration config = new CorsConfiguration();\n    config.setAllowCredentials(true); // 是否支持安全证书\n    config.addAllowedOrigin(&quot;*&quot;); // 允许任何域名使用\n    config.addAllowedHeader(&quot;*&quot;); // 允许任何头\n    config.addAllowedMethod(&quot;*&quot;); // 允许任何方法（post、get等）\n    // 预检请求的有效期，单位为秒。\n    //        config.setMaxAge(3600L);\n\n    source.registerCorsConfiguration(&quot;/**&quot;, config);\n    FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source));\n    bean.setOrder(0);\n    return bean;\n}\n</code></pre><h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2>","more":"</p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>前后端分离开发的场景已经趋于常态，跨域就必不可少</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">URL</th>\n<th style=\"text-align:center\">说明</th>\n<th style=\"text-align:center\">是否允许通信</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.baidu.com/a.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com/a.js</a><br><a href=\"http://www.baidu.com/b.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com/b.js</a></td>\n<td style=\"text-align:center\">同域</td>\n<td style=\"text-align:center\">允许通讯</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.baidu.com:8080/a.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com:8080/a.js</a><br><a href=\"http://www.baidu.com:8081/b.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com:8081/b.js</a></td>\n<td style=\"text-align:center\">同域不同端口</td>\n<td style=\"text-align:center\">不允许通信(跨域）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.baidu.com/a.js\" target=\"_blank\" rel=\"noopener\">www.baidu.com/a.js</a><br><a href=\"http://www.xxx.com/b.js\" target=\"_blank\" rel=\"noopener\">www.xxx.com/b.js</a></td>\n<td style=\"text-align:center\">不同域</td>\n<td style=\"text-align:center\">不允许通信(跨域）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"有哪些配置方式\"><a href=\"#有哪些配置方式\" class=\"headerlink\" title=\"有哪些配置方式\"></a>有哪些配置方式</h2><p>springboot的跨域一般有两种情况，请求上加注解和统一配置(configration/filter)，像我这样图方便的人就喜欢统一配置，网上的通用配置很多<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/5453f5d052139390a818050dd5fbaa9397107fd658f8070ab82928cd018b52bc0d8cb6b975ad2d0ef2953aada526ae86?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=1643994375&amp;fname=%E6%A2%AD.jpg&amp;size=750\" alt></p>\n<h2 id=\"哪儿尬\"><a href=\"#哪儿尬\" class=\"headerlink\" title=\"哪儿尬\"></a>哪儿尬</h2><p>然而尴尬的事情发生了，前端携带token请求后端接口时被拦截了500，仔细看了请求 发现浏览器在发送真实请求前会发送一个options预请求进行校验需要满足以下条件</p>\n<ul>\n<li>请求方法不是GET/HEAD/POST</li>\n<li>POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain</li>\n<li>请求设置了自定义的header字段</li>\n</ul>\n<p>显然 token并不属于官方请求头 那么就是这个通用失效的原因了，贴上这次使用的代码，下次不尬</p>\n<pre><code>@Bean\npublic FilterRegistrationBean corsFilter() {\n    // 注册CORS过滤器\n    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n    CorsConfiguration config = new CorsConfiguration();\n    config.setAllowCredentials(true); // 是否支持安全证书\n    config.addAllowedOrigin(&quot;*&quot;); // 允许任何域名使用\n    config.addAllowedHeader(&quot;*&quot;); // 允许任何头\n    config.addAllowedMethod(&quot;*&quot;); // 允许任何方法（post、get等）\n    // 预检请求的有效期，单位为秒。\n    //        config.setMaxAge(3600L);\n\n    source.registerCorsConfiguration(&quot;/**&quot;, config);\n    FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source));\n    bean.setOrder(0);\n    return bean;\n}\n</code></pre><h2 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h2>","categories":[],"tags":[{"name":"SpringBoot","path":"api/tags/SpringBoot.json"}]}